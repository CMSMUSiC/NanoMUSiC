<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.18" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="Doxygen Awesome" />
    <meta property="og:image"
        content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
    <meta property="og:description"
        content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
    <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
    <!-- END opengraph metadata -->
    <!-- BEGIN twitter metadata -->
    <meta name="twitter:image:src"
        content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
    <meta name="twitter:title" content="Doxygen Awesome" />
    <meta name="twitter:description"
        content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
    <!-- END twitter metadata -->
    <title>NanoMUSiC: Algorithms</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <link rel="icon" type="image/svg+xml" href="logo.drawio.svg" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript" src="toggle-alternative-theme.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.init()
    </script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- https://tholman.com/github-corners/ -->
    <a href="https://github.com/cmsmusic/nanomusic" class="github-corner" title="View source on GitHub" target="_blank">
        <svg viewBox="0 0 250 250" width="40" height="40"
            style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path
                d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
                fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path
                d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
                fill="currentColor" class="octo-body"></path>
        </svg></a>
    <style>
        .github-corner:hover .octo-arm {
            animation: octocat-wave 560ms ease-in-out
        }
        @keyframes octocat-wave {
            0%,
            100% {
                transform: rotate(0)
            }
            20%,
            60% {
                transform: rotate(-25deg)
            }
            40%,
            80% {
                transform: rotate(10deg)
            }
        }
        @media (max-width:500px) {
            .github-corner:hover .octo-arm {
                animation: none
            }
            .github-corner .octo-arm {
                animation: octocat-wave 560ms ease-in-out
            }
        }
    </style>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">NanoMUSiC
                            </div>
                            <div id="projectbrief">CMS MUSiC for NanoAOD</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms</div>  </div>
</div><!--header-->
<div class="contents">

<p>Iterator- and range-based algorithms, like the standard algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceranges_1_1cpp20"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceranges_1_1cpp20.html">ranges::cpp20</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structranges_1_1copy__fn.html">ranges::copy_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structranges_1_1move__fn.html">ranges::move_fn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplParams" colspan="2"><a id="gab309c6678ed7ad0eea22415f3d66514a"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gab309c6678ed7ad0eea22415f3d66514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplParams" colspan="2"><a id="ga58e197a7893ec8659fb7e2513130f7cf"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplParams" colspan="2"><a id="ga5a179c5b7b8620b7fd95dc315cab0a39"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplParams" colspan="2"><a id="gae2ac60776de9431e79a65c4897bd2e3d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_n_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplParams" colspan="2"><a id="ga84025d197692778e238c2143ee2dcdee"></a>
template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each_result</b> = detail::in_fun_result&lt; I, F &gt;</td></tr>
<tr class="separator:ga84025d197692778e238c2143ee2dcdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplParams" colspan="2"><a id="ga4b78921a0e76ce435f8c180041296192"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga4b78921a0e76ce435f8c180041296192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplParams" colspan="2"><a id="ga0cd85c482465e0fef02aec6733ec5e8a"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_n_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplParams" colspan="2"><a id="ga4fb3de5f6f61105bed9816cbbe1c20e4"></a>
template&lt;typename I0 , typename I1 , typename O &gt; </td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::merge_result</b> = detail::in1_in2_out_result&lt; I0, I1, O &gt;</td></tr>
<tr class="separator:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplParams" colspan="2"><a id="ga33d3732bfda9763bacb492f678c49ac2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_result</b> = detail::min_max_result&lt; <a class="el" href="structT.html">T</a>, <a class="el" href="structT.html">T</a> &gt;</td></tr>
<tr class="separator:ga33d3732bfda9763bacb492f678c49ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplParams" colspan="2"><a id="ga2551631b044f18c25ebf252d89ab62d1"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_element_result</b> = detail::min_max_result&lt; I, I &gt;</td></tr>
<tr class="separator:ga2551631b044f18c25ebf252d89ab62d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplParams" colspan="2"><a id="ga228c0cdeb71847092b416b855e17c017"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga228c0cdeb71847092b416b855e17c017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplParams" colspan="2"><a id="gaa9e56e40c245536a73cd3c4479aa71f0"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplParams" colspan="2"><a id="gaf3ddbe128fcdd14998784890ae88172c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf3ddbe128fcdd14998784890ae88172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplParams" colspan="2"><a id="ga196586ea2693c3b679d7c75c8c8c4eb2"></a>
template&lt;typename I , typename O0 , typename O1 &gt; </td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_copy_result</b> = detail::in_out1_out2_result&lt; I, O0, O1 &gt;</td></tr>
<tr class="separator:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplParams" colspan="2"><a id="gacbea707ae03721b200a22fe6918920d8"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gacbea707ae03721b200a22fe6918920d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplParams" colspan="2"><a id="ga81824d68277efdaa55addad2b5a1ab09"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga81824d68277efdaa55addad2b5a1ab09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplParams" colspan="2"><a id="gadf2b15655eb4ca83a6615695d37dc191"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gadf2b15655eb4ca83a6615695d37dc191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplParams" colspan="2"><a id="gaf4f4af78a9add9145c784b58d209e16e"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf4f4af78a9add9145c784b58d209e16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplParams" colspan="2"><a id="ga7bff287e5ec676e01a086ac147d4b618"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga7bff287e5ec676e01a086ac147d4b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplParams" colspan="2"><a id="gaebb905dac3fee120cf77b39e821c277c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaebb905dac3fee120cf77b39e821c277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplParams" colspan="2"><a id="ga8571d401e506014ea1a86618ca01545f"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga8571d401e506014ea1a86618ca01545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplParams" colspan="2"><a id="gaa28c664ec5818d4c1e4458486d109519"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_union_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa28c664ec5818d4c1e4458486d109519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplParams" colspan="2"><a id="ga46e34ec570ccc79f695689635145bed4"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_difference_result</b> = detail::in1_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga46e34ec570ccc79f695689635145bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplParams" colspan="2"><a id="gaa40276d355563038380b94ca8c500cd2"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_symmetric_difference_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa40276d355563038380b94ca8c500cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplParams" colspan="2"><a id="ga3a91c5c1590ec2c0cf1a56ea2e363dea"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplParams" colspan="2"><a id="gaef72d2db7ea1c57f60101e18336e4037"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unary_transform_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaef72d2db7ea1c57f60101e18336e4037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplParams" colspan="2"><a id="ga4ec55cd1aee7604d0c5a335fb3d8641b"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::binary_transform_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplParams" colspan="2"><a id="gaf7ea4487e401b787c778cbc28e43913d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unique_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf7ea4487e401b787c778cbc28e43913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga10408f1ef84603f755275f0af913b95b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga10408f1ef84603f755275f0af913b95b">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga10408f1ef84603f755275f0af913b95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>adjacent_find</code>  <a href="group__group-algorithms.html#ga10408f1ef84603f755275f0af913b95b">More...</a><br /></td></tr>
<tr class="separator:ga10408f1ef84603f755275f0af913b95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6509eba8c152fcef0d2bc3848fc9f6"><td class="memItemLeft" align="right" valign="top"><a id="ga7a6509eba8c152fcef0d2bc3848fc9f6"></a>
I AND constexpr indirect_relation&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::adjacent_find</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga7a6509eba8c152fcef0d2bc3848fc9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d9f7691d426c0b93dff05d19a36b97"><td class="memItemLeft" align="right" valign="top"><a id="ga21d9f7691d426c0b93dff05d19a36b97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga21d9f7691d426c0b93dff05d19a36b97">ranges::template</a> (typename Rng, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires forward_range&lt; Rng &gt; AND indirect_relation&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:ga21d9f7691d426c0b93dff05d19a36b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga21d9f7691d426c0b93dff05d19a36b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54634f0f5102cbf16a06c677f42d7f50"><td class="memItemLeft" align="right" valign="top"><a id="ga54634f0f5102cbf16a06c677f42d7f50"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::adjacent_find</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga54634f0f5102cbf16a06c677f42d7f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6a91d825b0ee47589afd4b3e7c0883"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1f6a91d825b0ee47589afd4b3e7c0883">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename Pred, typename Proj=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires permutable&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga1f6a91d825b0ee47589afd4b3e7c0883"><td class="mdescLeft">&#160;</td><td class="mdescRight">function <code>adjacent_remove_if</code>  <a href="group__group-algorithms.html#ga1f6a91d825b0ee47589afd4b3e7c0883">More...</a><br /></td></tr>
<tr class="separator:ga1f6a91d825b0ee47589afd4b3e7c0883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62657a6fd5fa0f5dbeba303e5161781c"><td class="memItemLeft" align="right" valign="top"><a id="ga62657a6fd5fa0f5dbeba303e5161781c"></a>
I AND constexpr indirect_relation&lt; Pred, projected&lt; I, Proj &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::adjacent_remove_if</b> (I first, <a class="el" href="structS.html">S</a> last, Pred <a class="el" href="structpred.html">pred</a>={}, Proj proj={})</td></tr>
<tr class="separator:ga62657a6fd5fa0f5dbeba303e5161781c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b7b9bf746a4fce4502470ccd7304e7"><td class="memItemLeft" align="right" valign="top"><a id="ga84b7b9bf746a4fce4502470ccd7304e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga84b7b9bf746a4fce4502470ccd7304e7">ranges::template</a> (typename Rng, typename Pred, typename Proj=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires forward_range&lt; Rng &gt; AND indirect_relation&lt; Pred</td></tr>
<tr class="memdesc:ga84b7b9bf746a4fce4502470ccd7304e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga84b7b9bf746a4fce4502470ccd7304e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af51dea010cb9af5e7817f8eb940b5c"><td class="memItemLeft" align="right" valign="top"><a id="ga2af51dea010cb9af5e7817f8eb940b5c"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, Proj &gt; AND constexpr permutable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::adjacent_remove_if</b> (Rng &amp;&amp;rng, Pred <a class="el" href="structpred.html">pred</a>, Proj proj={})</td></tr>
<tr class="separator:ga2af51dea010cb9af5e7817f8eb940b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab94ef31027b6722de9693dfc418b5461"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab94ef31027b6722de9693dfc418b5461">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename F, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gab94ef31027b6722de9693dfc418b5461"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>all_of</code>  <a href="group__group-algorithms.html#gab94ef31027b6722de9693dfc418b5461">More...</a><br /></td></tr>
<tr class="separator:gab94ef31027b6722de9693dfc418b5461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d2ec5326d952f2fda36eaa1d94444c"><td class="memItemLeft" align="right" valign="top"><a id="ga85d2ec5326d952f2fda36eaa1d94444c"></a>
I AND constexpr indirect_unary_predicate&lt; F, projected&lt; I, P &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::all_of</b> (I first, <a class="el" href="structS.html">S</a> last, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga85d2ec5326d952f2fda36eaa1d94444c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c66954e5dc0b1f6f739b119b6a7d25f"><td class="memItemLeft" align="right" valign="top"><a id="ga8c66954e5dc0b1f6f739b119b6a7d25f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8c66954e5dc0b1f6f739b119b6a7d25f">ranges::template</a> (typename Rng, typename F, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND indirect_unary_predicate&lt; F</td></tr>
<tr class="memdesc:ga8c66954e5dc0b1f6f739b119b6a7d25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga8c66954e5dc0b1f6f739b119b6a7d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6e5b5362f9f18d0b9b27d7ab2597a6"><td class="memItemLeft" align="right" valign="top"><a id="ga1b6e5b5362f9f18d0b9b27d7ab2597a6"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::all_of</b> (Rng &amp;&amp;rng, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga1b6e5b5362f9f18d0b9b27d7ab2597a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2627e00d5728f9ead7447d3bef3df360"><td class="memItemLeft" align="right" valign="top"><a id="ga2627e00d5728f9ead7447d3bef3df360"></a>
I AND constexpr indirect_unary_predicate&lt; F, projected&lt; I, P &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::any_of</b> (I first, <a class="el" href="structS.html">S</a> last, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga2627e00d5728f9ead7447d3bef3df360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9878b3145319178fcedef150a13de2b"><td class="memItemLeft" align="right" valign="top"><a id="gaa9878b3145319178fcedef150a13de2b"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::any_of</b> (Rng &amp;&amp;rng, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gaa9878b3145319178fcedef150a13de2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d5f20d5450ba794e98372dc88d3dbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga92d5f20d5450ba794e98372dc88d3dbf">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename V, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga92d5f20d5450ba794e98372dc88d3dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>binary_search</code>  <a href="group__group-algorithms.html#ga92d5f20d5450ba794e98372dc88d3dbf">More...</a><br /></td></tr>
<tr class="separator:ga92d5f20d5450ba794e98372dc88d3dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad742144614c05390ca34be74d0b87ba5"><td class="memItemLeft" align="right" valign="top"><a id="gad742144614c05390ca34be74d0b87ba5"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, V const *, projected&lt; I, P &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::binary_search</b> (I first, <a class="el" href="structS.html">S</a> last, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gad742144614c05390ca34be74d0b87ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797150b820c637e5bf531bcc40408a97"><td class="memItemLeft" align="right" valign="top"><a id="ga797150b820c637e5bf531bcc40408a97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga797150b820c637e5bf531bcc40408a97">ranges::template</a> (typename Rng, typename V, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires forward_range&lt; Rng &gt; AND indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:ga797150b820c637e5bf531bcc40408a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga797150b820c637e5bf531bcc40408a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8c9295bf3aba19f8361764a84e7732"><td class="memItemLeft" align="right" valign="top"><a id="ga6e8c9295bf3aba19f8361764a84e7732"></a>
V const constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::binary_search</b> (Rng &amp;&amp;rng, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga6e8c9295bf3aba19f8361764a84e7732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a4199c26c72a128231b2d0ae2cde77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga89a4199c26c72a128231b2d0ae2cde77">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga89a4199c26c72a128231b2d0ae2cde77"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>contains</code>  <a href="group__group-algorithms.html#ga89a4199c26c72a128231b2d0ae2cde77">More...</a><br /></td></tr>
<tr class="separator:ga89a4199c26c72a128231b2d0ae2cde77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb4443873c1fcc2c7fa09e672e9ae92"><td class="memItemLeft" align="right" valign="top"><a id="ga3cb4443873c1fcc2c7fa09e672e9ae92"></a>
I AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, const <a class="el" href="structT.html">T</a> * &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::contains</b> (I first, <a class="el" href="structS.html">S</a> last, const <a class="el" href="structT.html">T</a> &amp;val, P proj={})</td></tr>
<tr class="separator:ga3cb4443873c1fcc2c7fa09e672e9ae92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ac12a665d15992693a1bed1bb79e8e"><td class="memItemLeft" align="right" valign="top"><a id="gae9ac12a665d15992693a1bed1bb79e8e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae9ac12a665d15992693a1bed1bb79e8e">ranges::template</a> (typename Rng, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:gae9ac12a665d15992693a1bed1bb79e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gae9ac12a665d15992693a1bed1bb79e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a80e75ddc9e6cb2d0476c63de1a54be"><td class="memItemLeft" align="right" valign="top"><a id="ga1a80e75ddc9e6cb2d0476c63de1a54be"></a>
const <a class="el" href="structT.html">T</a> *constexpr bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::contains</b> (Rng &amp;&amp;rng, const <a class="el" href="structT.html">T</a> &amp;val, P proj={})</td></tr>
<tr class="separator:ga1a80e75ddc9e6cb2d0476c63de1a54be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab70f44c127c77f896b446afd4bc1ff05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab70f44c127c77f896b446afd4bc1ff05">ranges::template</a> (typename I1, typename S1, typename I2, typename S2, typename Pred=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename Proj1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename Proj2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I1 &gt; AND sentinel_for&lt; S1</td></tr>
<tr class="memdesc:gab70f44c127c77f896b446afd4bc1ff05"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>contains</code>  <a href="group__group-algorithms.html#gab70f44c127c77f896b446afd4bc1ff05">More...</a><br /></td></tr>
<tr class="separator:gab70f44c127c77f896b446afd4bc1ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7c750d11682fba1e2d4b2c122670d1"><td class="memItemLeft" align="right" valign="top"><a id="ga7a7c750d11682fba1e2d4b2c122670d1"></a>
I1 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I2 &gt; AND sentinel_for&lt; S2, I2 &gt; AND constexpr indirectly_comparable&lt; I1, I2, Pred, Proj1, Proj2 &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::contains</b> (I1 first1, S1 last1, I2 first2, S2 last2, Pred <a class="el" href="structpred.html">pred</a>={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="separator:ga7a7c750d11682fba1e2d4b2c122670d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31cfc61e5e607409f37adf5e91ef8b1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga31cfc61e5e607409f37adf5e91ef8b1f">ranges::template</a> (typename Rng1, typename Rng2, typename Pred=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename Proj1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename Proj2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires forward_range&lt; Rng1 &gt; AND forward_range&lt; Rng2 &gt; AND indirectly_comparable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;</td></tr>
<tr class="memdesc:ga31cfc61e5e607409f37adf5e91ef8b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga31cfc61e5e607409f37adf5e91ef8b1f">More...</a><br /></td></tr>
<tr class="separator:ga31cfc61e5e607409f37adf5e91ef8b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648fcc4f7eb456aec92fb847c0aa7185"><td class="memItemLeft" align="right" valign="top"><a id="ga648fcc4f7eb456aec92fb847c0aa7185"></a>
constexpr Proj2 bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::contains</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, Pred <a class="el" href="structpred.html">pred</a>={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="separator:ga648fcc4f7eb456aec92fb847c0aa7185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f32de3ff3d15e5852b3226d5dd7515"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga23f32de3ff3d15e5852b3226d5dd7515">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga23f32de3ff3d15e5852b3226d5dd7515"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy</code>  <a href="group__group-algorithms.html#ga23f32de3ff3d15e5852b3226d5dd7515">More...</a><br /></td></tr>
<tr class="separator:ga23f32de3ff3d15e5852b3226d5dd7515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga859137e613ddbf32f3572c5037eeb2b2"><td class="memItemLeft" align="right" valign="top"><a id="ga859137e613ddbf32f3572c5037eeb2b2"></a>
I AND weakly_incrementable&lt; O &gt; AND constexpr indirectly_copyable&lt; I, O &gt; copy_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::copy</b> (I first, <a class="el" href="structS.html">S</a> last, O out)</td></tr>
<tr class="separator:ga859137e613ddbf32f3572c5037eeb2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb7c11db0860f4e0cb66826ea69fea3"><td class="memItemLeft" align="right" valign="top"><a id="ga3bb7c11db0860f4e0cb66826ea69fea3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga3bb7c11db0860f4e0cb66826ea69fea3">ranges::template</a> (typename Rng, typename O)(requires input_range&lt; Rng &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;</td></tr>
<tr class="memdesc:ga3bb7c11db0860f4e0cb66826ea69fea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3bb7c11db0860f4e0cb66826ea69fea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4eb3cf5ae9c8e21dad0757bf12ad085"><td class="memItemLeft" align="right" valign="top"><a id="gaa4eb3cf5ae9c8e21dad0757bf12ad085"></a>
constexpr O copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::copy</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="separator:gaa4eb3cf5ae9c8e21dad0757bf12ad085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e2ac500d2af94210f5e81811e94422"><td class="memItemLeft" align="right" valign="top"><a id="gaf7e2ac500d2af94210f5e81811e94422"></a>
I AND bidirectional_iterator&lt; O &gt; AND constexpr indirectly_copyable&lt; I, O &gt; copy_backward_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::copy_backward</b> (I first, <a class="el" href="structS.html">S</a> end_, O out)</td></tr>
<tr class="separator:gaf7e2ac500d2af94210f5e81811e94422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3120f69d6ba8545fc8bf4962049ca70e"><td class="memItemLeft" align="right" valign="top"><a id="ga3120f69d6ba8545fc8bf4962049ca70e"></a>
O constexpr copy_backward_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::copy_backward</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="separator:ga3120f69d6ba8545fc8bf4962049ca70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48636515458ae0167941939918250650"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga48636515458ae0167941939918250650">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O, typename F, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga48636515458ae0167941939918250650"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_if</code>  <a href="group__group-algorithms.html#ga48636515458ae0167941939918250650">More...</a><br /></td></tr>
<tr class="separator:ga48636515458ae0167941939918250650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63cf82e7e40bea17cf7d58340528753c"><td class="memItemLeft" align="right" valign="top"><a id="ga63cf82e7e40bea17cf7d58340528753c"></a>
I AND weakly_incrementable&lt; O &gt; AND indirect_unary_predicate&lt; F, projected&lt; I, P &gt; &gt; AND constexpr indirectly_copyable&lt; I, O &gt; copy_if_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::copy_if</b> (I first, <a class="el" href="structS.html">S</a> last, O out, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga63cf82e7e40bea17cf7d58340528753c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13389a4bc9b545d5f8581acfb5580c03"><td class="memItemLeft" align="right" valign="top"><a id="ga13389a4bc9b545d5f8581acfb5580c03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga13389a4bc9b545d5f8581acfb5580c03">ranges::template</a> (typename Rng, typename O, typename F, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND weakly_incrementable&lt; O &gt; AND indirect_unary_predicate&lt; F</td></tr>
<tr class="memdesc:ga13389a4bc9b545d5f8581acfb5580c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga13389a4bc9b545d5f8581acfb5580c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b1477fe6f810b6ed189615c0d3d8e58"><td class="memItemLeft" align="right" valign="top"><a id="ga7b1477fe6f810b6ed189615c0d3d8e58"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND constexpr indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt; copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::copy_if</b> (Rng &amp;&amp;rng, O out, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga7b1477fe6f810b6ed189615c0d3d8e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2fd90c584118382b1c2c654edcc6b55"><td class="memItemLeft" align="right" valign="top"><a id="gaf2fd90c584118382b1c2c654edcc6b55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf2fd90c584118382b1c2c654edcc6b55">ranges::template</a> (typename I, typename O, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; I</td></tr>
<tr class="memdesc:gaf2fd90c584118382b1c2c654edcc6b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_n</code> <br /></td></tr>
<tr class="separator:gaf2fd90c584118382b1c2c654edcc6b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef3f6af4f740eb1e54025c486598779"><td class="memItemLeft" align="right" valign="top"><a id="ga8ef3f6af4f740eb1e54025c486598779"></a>
constexpr O copy_n_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::copy_n</b> (I first, iter_difference_t&lt; I &gt; n, O out)</td></tr>
<tr class="separator:ga8ef3f6af4f740eb1e54025c486598779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50641d7749eee48ff05de71d75d089ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga50641d7749eee48ff05de71d75d089ac">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename V, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga50641d7749eee48ff05de71d75d089ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count</code>  <a href="group__group-algorithms.html#ga50641d7749eee48ff05de71d75d089ac">More...</a><br /></td></tr>
<tr class="separator:ga50641d7749eee48ff05de71d75d089ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8091d065286776e3788576defc0708ee"><td class="memItemLeft" align="right" valign="top"><a id="ga8091d065286776e3788576defc0708ee"></a>
I AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, V const * &gt; iter_difference_t&lt; I &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::count</b> (I first, <a class="el" href="structS.html">S</a> last, V const &amp;val, P proj=P{})</td></tr>
<tr class="separator:ga8091d065286776e3788576defc0708ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c2ee169dfa61da09f63cdec7b7f97c3"><td class="memItemLeft" align="right" valign="top"><a id="ga9c2ee169dfa61da09f63cdec7b7f97c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9c2ee169dfa61da09f63cdec7b7f97c3">ranges::template</a> (typename Rng, typename V, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:ga9c2ee169dfa61da09f63cdec7b7f97c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga9c2ee169dfa61da09f63cdec7b7f97c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb68a0bb4d584d7baf67d8df9a984c4c"><td class="memItemLeft" align="right" valign="top"><a id="gafb68a0bb4d584d7baf67d8df9a984c4c"></a>
V const  *constexpr iter_difference_t&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::count</b> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{})</td></tr>
<tr class="separator:gafb68a0bb4d584d7baf67d8df9a984c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65287ec19b97d90dc9eabcff185cea5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac65287ec19b97d90dc9eabcff185cea5">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename R, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gac65287ec19b97d90dc9eabcff185cea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count_if</code>  <a href="group__group-algorithms.html#gac65287ec19b97d90dc9eabcff185cea5">More...</a><br /></td></tr>
<tr class="separator:gac65287ec19b97d90dc9eabcff185cea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762198313f9c85c10cca28f06eb90049"><td class="memItemLeft" align="right" valign="top"><a id="ga762198313f9c85c10cca28f06eb90049"></a>
I AND constexpr indirect_unary_predicate&lt; R, projected&lt; I, P &gt; &gt; iter_difference_t&lt; I &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::count_if</b> (I first, <a class="el" href="structS.html">S</a> last, R <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga762198313f9c85c10cca28f06eb90049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d09424009550cb1e107f90ef79102b5"><td class="memItemLeft" align="right" valign="top"><a id="ga5d09424009550cb1e107f90ef79102b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5d09424009550cb1e107f90ef79102b5">ranges::template</a> (typename Rng, typename R, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND indirect_unary_predicate&lt; R</td></tr>
<tr class="memdesc:ga5d09424009550cb1e107f90ef79102b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga5d09424009550cb1e107f90ef79102b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae189b5d8a7a6c6f3535bbd450a82ce5d"><td class="memItemLeft" align="right" valign="top"><a id="gae189b5d8a7a6c6f3535bbd450a82ce5d"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; iter_difference_t&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::count_if</b> (Rng &amp;&amp;rng, R <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gae189b5d8a7a6c6f3535bbd450a82ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6565aa452a9e7bc18fc727f2bfadbc"><td class="memItemLeft" align="right" valign="top"><a id="ga5d6565aa452a9e7bc18fc727f2bfadbc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5d6565aa452a9e7bc18fc727f2bfadbc">ranges::template</a> (typename I0, typename S0, typename I1, typename S1, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires((<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0</td></tr>
<tr class="memdesc:ga5d6565aa452a9e7bc18fc727f2bfadbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>ends_with</code> <br /></td></tr>
<tr class="separator:ga5d6565aa452a9e7bc18fc727f2bfadbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f9557a357ea5c0c77ba87b18640d90"><td class="memItemLeft" align="right" valign="top"><a id="ga98f9557a357ea5c0c77ba87b18640d90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::I0</b> (input_iterator&lt; I0 &gt; &amp;&amp;sized_sentinel_for&lt; S0, I0 &gt;)) AND((<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1</td></tr>
<tr class="separator:ga98f9557a357ea5c0c77ba87b18640d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d1ba36ad1ab8d99102a3074cd6ce1e2"><td class="memItemLeft" align="right" valign="top"><a id="ga8d1ba36ad1ab8d99102a3074cd6ce1e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::I1</b> (input_iterator&lt; I1 &gt; &amp;&amp;sized_sentinel_for&lt; S1, I1 &gt;)) AND indirectly_comparable&lt; I0</td></tr>
<tr class="separator:ga8d1ba36ad1ab8d99102a3074cd6ce1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bb9e08ee9d851a3c009d65d9011278"><td class="memItemLeft" align="right" valign="top"><a id="ga64bb9e08ee9d851a3c009d65d9011278"></a>
constexpr P1 bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::ends_with</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga64bb9e08ee9d851a3c009d65d9011278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a9865b542815583df06c5ca75e1390"><td class="memItemLeft" align="right" valign="top"><a id="ga11a9865b542815583df06c5ca75e1390"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga11a9865b542815583df06c5ca75e1390">ranges::template</a> (typename Rng0, typename Rng1, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires(forward_range&lt; Rng0 &gt;||(input_range&lt; Rng0 &gt; &amp;&amp;sized_range&lt; Rng0 &gt;)) AND(forward_range&lt; Rng1 &gt;||(input_range&lt; Rng1 &gt; &amp;&amp;sized_range&lt; Rng1 &gt;)) AND indirectly_comparable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng0 &gt;</td></tr>
<tr class="memdesc:ga11a9865b542815583df06c5ca75e1390"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga11a9865b542815583df06c5ca75e1390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8678c3f17626a43c2a247192afec19a8"><td class="memItemLeft" align="right" valign="top"><a id="ga8678c3f17626a43c2a247192afec19a8"></a>
constexpr P1 bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::ends_with</b> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga8678c3f17626a43c2a247192afec19a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef5d699744878f3cfead85b71c9e00f"><td class="memItemLeft" align="right" valign="top"><a id="ga9ef5d699744878f3cfead85b71c9e00f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9ef5d699744878f3cfead85b71c9e00f">ranges::template</a> (typename I0, typename S0, typename I1, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I0 &gt; AND sentinel_for&lt; S0</td></tr>
<tr class="memdesc:ga9ef5d699744878f3cfead85b71c9e00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code> <br /></td></tr>
<tr class="separator:ga9ef5d699744878f3cfead85b71c9e00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9db0fbdbf2c1c784f9e235247871ecd"><td class="memItemLeft" align="right" valign="top"><a id="gad9db0fbdbf2c1c784f9e235247871ecd"></a>
I0 AND input_iterator&lt; I1 &gt; AND indirectly_comparable&lt; I0, I1, <a class="el" href="classC.html">C</a>, P0, P1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::RANGES_DEPRECATED</b> (&quot;Use the <a class="el" href="structranges_1_1variant.html">variant</a> of ranges::equal that takes an upper bound for &quot; &quot;both sequences&quot;) const expr bool RANGES_FUNC(equal)(I0 begin0</td></tr>
<tr class="separator:gad9db0fbdbf2c1c784f9e235247871ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec7c9a502ddac69cf62541f51e7cb8f"><td class="memItemLeft" align="right" valign="top"><a id="gacec7c9a502ddac69cf62541f51e7cb8f"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, V const *, projected&lt; I, P &gt; &gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::equal_range</b> (I first, <a class="el" href="structS.html">S</a> last, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gacec7c9a502ddac69cf62541f51e7cb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844c5e83d673d8e6a48a53e1d8856bb1"><td class="memItemLeft" align="right" valign="top"><a id="ga844c5e83d673d8e6a48a53e1d8856bb1"></a>
V const constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_subrange_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::equal_range</b> (Rng &amp;&amp;rng, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga844c5e83d673d8e6a48a53e1d8856bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c8e2aa5dd8e826e058d8fbebc160ac"><td class="memItemLeft" align="right" valign="top"><a id="ga86c8e2aa5dd8e826e058d8fbebc160ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga86c8e2aa5dd8e826e058d8fbebc160ac">ranges::template</a> (typename O, typename <a class="el" href="structS.html">S</a>, typename V)(requires output_iterator&lt; O</td></tr>
<tr class="memdesc:ga86c8e2aa5dd8e826e058d8fbebc160ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>fill</code> <br /></td></tr>
<tr class="separator:ga86c8e2aa5dd8e826e058d8fbebc160ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d98d508a340e3ef5dce126f99c3b53"><td class="memItemLeft" align="right" valign="top"><a id="gac8d98d508a340e3ef5dce126f99c3b53"></a>
V const  &amp;AND constexpr sentinel_for&lt; <a class="el" href="structS.html">S</a>, O &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fill</b> (O first, <a class="el" href="structS.html">S</a> last, V const &amp;val)</td></tr>
<tr class="separator:gac8d98d508a340e3ef5dce126f99c3b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138adaea7ea0f2154ebfbd46dbcc051f"><td class="memItemLeft" align="right" valign="top"><a id="ga138adaea7ea0f2154ebfbd46dbcc051f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga138adaea7ea0f2154ebfbd46dbcc051f">ranges::template</a> (typename Rng, typename V)(requires output_range&lt; Rng</td></tr>
<tr class="memdesc:ga138adaea7ea0f2154ebfbd46dbcc051f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga138adaea7ea0f2154ebfbd46dbcc051f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2d748559ac4be14c86cabec7bfc3b2"><td class="memItemLeft" align="right" valign="top"><a id="ga9e2d748559ac4be14c86cabec7bfc3b2"></a>
V const  &amp;constexpr borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fill</b> (Rng &amp;&amp;rng, V const &amp;val)</td></tr>
<tr class="separator:ga9e2d748559ac4be14c86cabec7bfc3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b777d0ebc53f7142a4cdb3d5e9c472"><td class="memItemLeft" align="right" valign="top"><a id="ga90b777d0ebc53f7142a4cdb3d5e9c472"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga90b777d0ebc53f7142a4cdb3d5e9c472">ranges::template</a> (typename O, typename V)(requires output_iterator&lt; O</td></tr>
<tr class="memdesc:ga90b777d0ebc53f7142a4cdb3d5e9c472"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code> <br /></td></tr>
<tr class="separator:ga90b777d0ebc53f7142a4cdb3d5e9c472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773721e28242afeb6db21c88866b77a9"><td class="memItemLeft" align="right" valign="top"><a id="ga773721e28242afeb6db21c88866b77a9"></a>
V const  &amp;constexpr O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fill_n</b> (O first, iter_difference_t&lt; O &gt; n, V const &amp;val)</td></tr>
<tr class="separator:ga773721e28242afeb6db21c88866b77a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4b3caa21a15e8f920a294d1e17963c"><td class="memItemLeft" align="right" valign="top"><a id="ga1a4b3caa21a15e8f920a294d1e17963c"></a>
I AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, V const * &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find</b> (I first, <a class="el" href="structS.html">S</a> last, V const &amp;val, P proj=P{})</td></tr>
<tr class="separator:ga1a4b3caa21a15e8f920a294d1e17963c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5e75e8a4a506cf62bab714456f6307"><td class="memItemLeft" align="right" valign="top"><a id="ga0d5e75e8a4a506cf62bab714456f6307"></a>
V const  *constexpr borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find</b> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{})</td></tr>
<tr class="separator:ga0d5e75e8a4a506cf62bab714456f6307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4008bd1730b04bdb642805ce8ba293e7"><td class="memItemLeft" align="right" valign="top"><a id="ga4008bd1730b04bdb642805ce8ba293e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4008bd1730b04bdb642805ce8ba293e7">ranges::template</a> (typename I1, typename S1, typename I2, typename S2, typename R=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I1 &gt; AND sentinel_for&lt; S1</td></tr>
<tr class="memdesc:ga4008bd1730b04bdb642805ce8ba293e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_end</code> <br /></td></tr>
<tr class="separator:ga4008bd1730b04bdb642805ce8ba293e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368674222a2e5579824ee31261a89898"><td class="memItemLeft" align="right" valign="top"><a id="ga368674222a2e5579824ee31261a89898"></a>
I1 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I2 &gt; AND sentinel_for&lt; S2, I2 &gt; AND constexpr indirect_relation&lt; R, projected&lt; I1, P &gt;, I2 &gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_end</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, R <a class="el" href="structpred.html">pred</a>=R{}, P proj=P{})</td></tr>
<tr class="separator:ga368674222a2e5579824ee31261a89898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f9f564bc1fda84cfcb8a866b8a85436"><td class="memItemLeft" align="right" valign="top"><a id="ga7f9f564bc1fda84cfcb8a866b8a85436"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7f9f564bc1fda84cfcb8a866b8a85436">ranges::template</a> (typename Rng1, typename Rng2, typename R=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires forward_range&lt; Rng1 &gt; AND forward_range&lt; Rng2 &gt; AND indirect_relation&lt; R</td></tr>
<tr class="memdesc:ga7f9f564bc1fda84cfcb8a866b8a85436"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga7f9f564bc1fda84cfcb8a866b8a85436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9f1e0af0885f51c270acc98c912b9c"><td class="memItemLeft" align="right" valign="top"><a id="ga9f9f1e0af0885f51c270acc98c912b9c"></a>
constexpr <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng2 &gt; borrowed_subrange_t&lt; Rng1 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_end</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, R <a class="el" href="structpred.html">pred</a>=R{}, P proj=P{})</td></tr>
<tr class="separator:ga9f9f1e0af0885f51c270acc98c912b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeee7cb8ba5bba39cc48ae67de56a4de"><td class="memItemLeft" align="right" valign="top"><a id="gadeee7cb8ba5bba39cc48ae67de56a4de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gadeee7cb8ba5bba39cc48ae67de56a4de">ranges::template</a> (typename I0, typename S0, typename I1, typename S1, typename R=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I0 &gt; AND sentinel_for&lt; S0</td></tr>
<tr class="memdesc:gadeee7cb8ba5bba39cc48ae67de56a4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_first_of</code> <br /></td></tr>
<tr class="separator:gadeee7cb8ba5bba39cc48ae67de56a4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2deba3e0cc63d57108b9ab9b7025bd49"><td class="memItemLeft" align="right" valign="top"><a id="ga2deba3e0cc63d57108b9ab9b7025bd49"></a>
I0 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I1 &gt; AND sentinel_for&lt; S1, I1 &gt; AND constexpr indirect_relation&lt; R, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt; &gt; I0 RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_first_of</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, R <a class="el" href="structpred.html">pred</a>=R{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga2deba3e0cc63d57108b9ab9b7025bd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7e770eae7b74c27cfcec8d16adc304"><td class="memItemLeft" align="right" valign="top"><a id="ga0f7e770eae7b74c27cfcec8d16adc304"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0f7e770eae7b74c27cfcec8d16adc304">ranges::template</a> (typename Rng0, typename Rng1, typename R=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng0 &gt; AND forward_range&lt; Rng1 &gt; AND indirect_relation&lt; R</td></tr>
<tr class="memdesc:ga0f7e770eae7b74c27cfcec8d16adc304"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga0f7e770eae7b74c27cfcec8d16adc304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75c9219397623f8262bdfc1d655c47d"><td class="memItemLeft" align="right" valign="top"><a id="gac75c9219397623f8262bdfc1d655c47d"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;, P1 &gt; borrowed_iterator_t&lt; Rng0 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_first_of</b> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, R <a class="el" href="structpred.html">pred</a>=R{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:gac75c9219397623f8262bdfc1d655c47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac939580637bd25180c121585e0672675"><td class="memItemLeft" align="right" valign="top"><a id="gac939580637bd25180c121585e0672675"></a>
I AND constexpr indirect_unary_predicate&lt; F, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_if</b> (I first, <a class="el" href="structS.html">S</a> last, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gac939580637bd25180c121585e0672675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbeed17a5734a7290433fee2de3b38c7"><td class="memItemLeft" align="right" valign="top"><a id="gadbeed17a5734a7290433fee2de3b38c7"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_if</b> (Rng &amp;&amp;rng, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gadbeed17a5734a7290433fee2de3b38c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad775a2351aba637f0e9192666ca1d9"><td class="memItemLeft" align="right" valign="top"><a id="gadad775a2351aba637f0e9192666ca1d9"></a>
I AND constexpr indirect_unary_predicate&lt; F, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_if_not</b> (I first, <a class="el" href="structS.html">S</a> last, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gadad775a2351aba637f0e9192666ca1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84a51ef8184f1a7a0f45ed93224ecc8"><td class="memItemLeft" align="right" valign="top"><a id="gac84a51ef8184f1a7a0f45ed93224ecc8"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::find_if_not</b> (Rng &amp;&amp;rng, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gac84a51ef8184f1a7a0f45ed93224ecc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26543688df8c255953c556ed7bf50fbf"><td class="memItemLeft" align="right" valign="top"><a id="ga26543688df8c255953c556ed7bf50fbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::template</b> (typename I, typename <a class="el" href="structS.html">S</a>, typename <a class="el" href="structT.html">T</a>, typename Op)(requires sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="separator:ga26543688df8c255953c556ed7bf50fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ff8d6af09f38554d2e212248c4ae17"><td class="memItemLeft" align="right" valign="top"><a id="gab8ff8d6af09f38554d2e212248c4ae17"></a>
I AND input_iterator&lt; I &gt; AND constexpr indirectly_binary_left_foldable&lt; Op, <a class="el" href="structT.html">T</a>, I &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_left</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="structT.html">T</a> init, Op op)</td></tr>
<tr class="separator:gab8ff8d6af09f38554d2e212248c4ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbdffa076b06ba8c66491788c75b986"><td class="memItemLeft" align="right" valign="top"><a id="gaecbdffa076b06ba8c66491788c75b986"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::template</b> (typename Rng, typename <a class="el" href="structT.html">T</a>, typename Op)(requires input_range&lt; Rng &gt; AND indirectly_binary_left_foldable&lt; Op</td></tr>
<tr class="separator:gaecbdffa076b06ba8c66491788c75b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546084473ed829038f1344e3b1c00049"><td class="memItemLeft" align="right" valign="top"><a id="ga546084473ed829038f1344e3b1c00049"></a>
constexpr <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_left</b> (Rng &amp;&amp;rng, <a class="el" href="structT.html">T</a> init, Op op)</td></tr>
<tr class="separator:ga546084473ed829038f1344e3b1c00049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aeb97aca33d84e9e15a23d3e41a29cb"><td class="memItemLeft" align="right" valign="top"><a id="ga5aeb97aca33d84e9e15a23d3e41a29cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::template</b> (typename I, typename <a class="el" href="structS.html">S</a>, typename Op)(requires sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="separator:ga5aeb97aca33d84e9e15a23d3e41a29cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9bd1dd537ca010bec369681cc26c658"><td class="memItemLeft" align="right" valign="top"><a id="gae9bd1dd537ca010bec369681cc26c658"></a>
I AND input_iterator&lt; I &gt; AND indirectly_binary_left_foldable&lt; Op, iter_value_t&lt; I &gt;, I &gt; AND constexpr constructible_from&lt; iter_value_t&lt; I &gt;, iter_reference_t&lt; I &gt; &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_left_first</b> (I first, <a class="el" href="structS.html">S</a> last, Op op)</td></tr>
<tr class="separator:gae9bd1dd537ca010bec369681cc26c658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84222708f0de89bc559ad0feca61cfe"><td class="memItemLeft" align="right" valign="top"><a id="gaf84222708f0de89bc559ad0feca61cfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::template</b> (typename R, typename Op)(requires input_range&lt; R &gt; AND indirectly_binary_left_foldable&lt; Op</td></tr>
<tr class="separator:gaf84222708f0de89bc559ad0feca61cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06774ee93e5401e994b9fe1d29b2c667"><td class="memItemLeft" align="right" valign="top"><a id="ga06774ee93e5401e994b9fe1d29b2c667"></a>
<a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; R &gt; AND constexpr constructible_from&lt; range_value_t&lt; R &gt;, range_reference_t&lt; R &gt; &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_left_first</b> (R &amp;&amp;rng, Op op)</td></tr>
<tr class="separator:ga06774ee93e5401e994b9fe1d29b2c667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e20edac15a4cf24d191c341a17cdf0"><td class="memItemLeft" align="right" valign="top"><a id="ga52e20edac15a4cf24d191c341a17cdf0"></a>
I AND bidirectional_iterator&lt; I &gt; AND constexpr indirectly_binary_right_foldable&lt; Op, <a class="el" href="structT.html">T</a>, I &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_right</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="structT.html">T</a> init, Op op)</td></tr>
<tr class="separator:ga52e20edac15a4cf24d191c341a17cdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617602a43a0ac3ed140d7db67537fa98"><td class="memItemLeft" align="right" valign="top"><a id="ga617602a43a0ac3ed140d7db67537fa98"></a>
constexpr <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_right</b> (Rng &amp;&amp;rng, <a class="el" href="structT.html">T</a> init, Op op)</td></tr>
<tr class="separator:ga617602a43a0ac3ed140d7db67537fa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b1a3cf83c96edd0aacd5f374983b2a7"><td class="memItemLeft" align="right" valign="top"><a id="ga4b1a3cf83c96edd0aacd5f374983b2a7"></a>
I AND bidirectional_iterator&lt; I &gt; AND indirectly_binary_right_foldable&lt; Op, iter_value_t&lt; I &gt;, I &gt; AND constexpr constructible_from&lt; iter_value_t&lt; I &gt;, iter_reference_t&lt; I &gt; &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_right_last</b> (I first, <a class="el" href="structS.html">S</a> last, Op op)</td></tr>
<tr class="separator:ga4b1a3cf83c96edd0aacd5f374983b2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9a5a5f20b7b454c5b014dc8c3df47f"><td class="memItemLeft" align="right" valign="top"><a id="ga5c9a5a5f20b7b454c5b014dc8c3df47f"></a>
<a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; R &gt; AND constexpr constructible_from&lt; range_value_t&lt; R &gt;, range_reference_t&lt; R &gt; &gt; auto RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::fold_right_last</b> (R &amp;&amp;rng, Op op)</td></tr>
<tr class="separator:ga5c9a5a5f20b7b454c5b014dc8c3df47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdd24efdef9656e05a32d2614845dc6"><td class="memItemLeft" align="right" valign="top"><a id="ga6bdd24efdef9656e05a32d2614845dc6"></a>
I AND constexpr indirectly_unary_invocable&lt; F, projected&lt; I, P &gt; &gt; for_each_result&lt; I, F &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::for_each</b> (I first, <a class="el" href="structS.html">S</a> last, F fun, P proj=P{})</td></tr>
<tr class="separator:ga6bdd24efdef9656e05a32d2614845dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9fb1b472479d98b9e39e3d86998b45"><td class="memItemLeft" align="right" valign="top"><a id="ga2b9fb1b472479d98b9e39e3d86998b45"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; for_each_result&lt; borrowed_iterator_t&lt; Rng &gt;, F &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::for_each</b> (Rng &amp;&amp;rng, F fun, P proj=P{})</td></tr>
<tr class="separator:ga2b9fb1b472479d98b9e39e3d86998b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c5ddc90239fde26d584118dc2db087"><td class="memItemLeft" align="right" valign="top"><a id="ga89c5ddc90239fde26d584118dc2db087"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga89c5ddc90239fde26d584118dc2db087">ranges::template</a> (typename I, typename F, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND indirectly_unary_invocable&lt; F</td></tr>
<tr class="memdesc:ga89c5ddc90239fde26d584118dc2db087"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>for_each_n</code> <br /></td></tr>
<tr class="separator:ga89c5ddc90239fde26d584118dc2db087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29944bb447c16b4f59e3d1e748134e40"><td class="memItemLeft" align="right" valign="top"><a id="ga29944bb447c16b4f59e3d1e748134e40"></a>
constexpr projected&lt; I, P &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::for_each_n</b> (I first, iter_difference_t&lt; I &gt; n, F fun, P proj=P{})</td></tr>
<tr class="separator:ga29944bb447c16b4f59e3d1e748134e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f65ac20c1c77e6a8d279e32eccb79db"><td class="memItemLeft" align="right" valign="top"><a id="ga6f65ac20c1c77e6a8d279e32eccb79db"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::for_each_n</b> (Rng &amp;&amp;rng, range_difference_t&lt; Rng &gt; n, F fun, P proj=P{})</td></tr>
<tr class="separator:ga6f65ac20c1c77e6a8d279e32eccb79db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9f665b998bc558c4b304b504a8e82f"><td class="memItemLeft" align="right" valign="top"><a id="gabb9f665b998bc558c4b304b504a8e82f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabb9f665b998bc558c4b304b504a8e82f">ranges::template</a> (typename O, typename <a class="el" href="structS.html">S</a>, typename F)(requires invocable&lt; F &amp; &gt; AND output_iterator&lt; O</td></tr>
<tr class="memdesc:gabb9f665b998bc558c4b304b504a8e82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code> <br /></td></tr>
<tr class="separator:gabb9f665b998bc558c4b304b504a8e82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a46603832cfbc5553fae6eadebac25"><td class="memItemLeft" align="right" valign="top"><a id="ga41a46603832cfbc5553fae6eadebac25"></a>
invoke_result_t&lt; F &amp; &gt; AND constexpr sentinel_for&lt; <a class="el" href="structS.html">S</a>, O &gt; generate_result&lt; O, F &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::generate</b> (O first, <a class="el" href="structS.html">S</a> last, F fun)</td></tr>
<tr class="separator:ga41a46603832cfbc5553fae6eadebac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01e1dc32bd668d09b9763750a609bbd"><td class="memItemLeft" align="right" valign="top"><a id="gae01e1dc32bd668d09b9763750a609bbd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae01e1dc32bd668d09b9763750a609bbd">ranges::template</a> (typename Rng, typename F)(requires invocable&lt; F &amp; &gt; AND output_range&lt; Rng</td></tr>
<tr class="memdesc:gae01e1dc32bd668d09b9763750a609bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gae01e1dc32bd668d09b9763750a609bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59bdd156197d71375cd3e0d29d1b3b60"><td class="memItemLeft" align="right" valign="top"><a id="ga59bdd156197d71375cd3e0d29d1b3b60"></a>
constexpr invoke_result_t&lt; F &amp; &gt; generate_result&lt; borrowed_iterator_t&lt; Rng &gt;, F &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::generate</b> (Rng &amp;&amp;rng, F fun)</td></tr>
<tr class="separator:ga59bdd156197d71375cd3e0d29d1b3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2886e1fdbeaaeef854c9ffa7fc52094c"><td class="memItemLeft" align="right" valign="top"><a id="ga2886e1fdbeaaeef854c9ffa7fc52094c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2886e1fdbeaaeef854c9ffa7fc52094c">ranges::template</a> (typename O, typename F)(requires invocable&lt; F &amp; &gt; AND output_iterator&lt; O</td></tr>
<tr class="memdesc:ga2886e1fdbeaaeef854c9ffa7fc52094c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code> <br /></td></tr>
<tr class="separator:ga2886e1fdbeaaeef854c9ffa7fc52094c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7740364032d10a14943654ee172840"><td class="memItemLeft" align="right" valign="top"><a id="ga1f7740364032d10a14943654ee172840"></a>
constexpr invoke_result_t&lt; F &amp; &gt; generate_n_result&lt; O, F &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::generate_n</b> (O first, iter_difference_t&lt; O &gt; n, F fun)</td></tr>
<tr class="separator:ga1f7740364032d10a14943654ee172840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c37e04a6014a1652b6c251f5a76400"><td class="memItemLeft" align="right" valign="top"><a id="ga21c37e04a6014a1652b6c251f5a76400"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_heap_until</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga21c37e04a6014a1652b6c251f5a76400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f302741d447caab9e3cec240302218"><td class="memItemLeft" align="right" valign="top"><a id="ga21f302741d447caab9e3cec240302218"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_heap_until</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga21f302741d447caab9e3cec240302218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2589ef355f39bb56ee565052dc4b8def"><td class="memItemLeft" align="right" valign="top"><a id="ga2589ef355f39bb56ee565052dc4b8def"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_heap</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga2589ef355f39bb56ee565052dc4b8def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d9f20beea8b01e42d768889bf916b0"><td class="memItemLeft" align="right" valign="top"><a id="ga47d9f20beea8b01e42d768889bf916b0"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_heap</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga47d9f20beea8b01e42d768889bf916b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f53b987f720328fcd2be5c480538b6c"><td class="memItemLeft" align="right" valign="top"><a id="ga3f53b987f720328fcd2be5c480538b6c"></a>
I AND constexpr sortable&lt; I, <a class="el" href="classC.html">C</a>, P &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::push_heap</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga3f53b987f720328fcd2be5c480538b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4cf6f1d6c438bab458f4e6439b9c32d"><td class="memItemLeft" align="right" valign="top"><a id="gaf4cf6f1d6c438bab458f4e6439b9c32d"></a>
constexpr P borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::push_heap</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaf4cf6f1d6c438bab458f4e6439b9c32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72fa2a495317603d7d7e555347414dce"><td class="memItemLeft" align="right" valign="top"><a id="ga72fa2a495317603d7d7e555347414dce"></a>
I AND constexpr sortable&lt; I, <a class="el" href="classC.html">C</a>, P &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::pop_heap</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga72fa2a495317603d7d7e555347414dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f3ab388493d31c879c7ac94ebf28f9"><td class="memItemLeft" align="right" valign="top"><a id="gae6f3ab388493d31c879c7ac94ebf28f9"></a>
constexpr P borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::pop_heap</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gae6f3ab388493d31c879c7ac94ebf28f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00eb98b7aac1a4970f679bc68b97da7"><td class="memItemLeft" align="right" valign="top"><a id="gac00eb98b7aac1a4970f679bc68b97da7"></a>
I AND constexpr sortable&lt; I, <a class="el" href="classC.html">C</a>, P &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::make_heap</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gac00eb98b7aac1a4970f679bc68b97da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e54e119cc8cc2221a8f86650e538869"><td class="memItemLeft" align="right" valign="top"><a id="ga0e54e119cc8cc2221a8f86650e538869"></a>
constexpr P borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::make_heap</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga0e54e119cc8cc2221a8f86650e538869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0599aa00fa0532669ed7d222569dfa"><td class="memItemLeft" align="right" valign="top"><a id="gaba0599aa00fa0532669ed7d222569dfa"></a>
I AND constexpr sortable&lt; I, <a class="el" href="classC.html">C</a>, P &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sort_heap</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaba0599aa00fa0532669ed7d222569dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84c223bb2bbfebaff1ee239e79c680a"><td class="memItemLeft" align="right" valign="top"><a id="gaf84c223bb2bbfebaff1ee239e79c680a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::template</b> (typename Rng, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires random_access_range&lt; Rng &amp; &gt; AND sortable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;</td></tr>
<tr class="separator:gaf84c223bb2bbfebaff1ee239e79c680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3993308dffa38f38c853c3477d44c2"><td class="memItemLeft" align="right" valign="top"><a id="gafd3993308dffa38f38c853c3477d44c2"></a>
constexpr P borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sort_heap</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gafd3993308dffa38f38c853c3477d44c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16f8773789b2458bebdfb8f15727e6b"><td class="memItemLeft" align="right" valign="top"><a id="gaa16f8773789b2458bebdfb8f15727e6b"></a>
P I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::inplace_merge</b> (I first, I middle, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaa16f8773789b2458bebdfb8f15727e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd5d0d32fa39b30bdef377ed081ff95"><td class="memItemLeft" align="right" valign="top"><a id="gaffd5d0d32fa39b30bdef377ed081ff95"></a>
P borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::inplace_merge</b> (Rng &amp;&amp;rng, <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; middle, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaffd5d0d32fa39b30bdef377ed081ff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13757696c7f73fede1b92bf6f7fb1f4a"><td class="memItemLeft" align="right" valign="top"><a id="ga13757696c7f73fede1b92bf6f7fb1f4a"></a>
I AND constexpr indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_partitioned</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga13757696c7f73fede1b92bf6f7fb1f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c01dbb582efd4d80545e7908db1c62e"><td class="memItemLeft" align="right" valign="top"><a id="ga0c01dbb582efd4d80545e7908db1c62e"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_partitioned</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga0c01dbb582efd4d80545e7908db1c62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d6195b014f40e4b2005c979b6ead8cd"><td class="memItemLeft" align="right" valign="top"><a id="ga7d6195b014f40e4b2005c979b6ead8cd"></a>
I AND constexpr indirect_strict_weak_order&lt; R, projected&lt; I, P &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_sorted</b> (I first, <a class="el" href="structS.html">S</a> last, R rel=R{}, P proj=P{})</td></tr>
<tr class="separator:ga7d6195b014f40e4b2005c979b6ead8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8947a9b8ad8f366f3603012c4a2ef0b2"><td class="memItemLeft" align="right" valign="top"><a id="ga8947a9b8ad8f366f3603012c4a2ef0b2"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_sorted</b> (Rng &amp;&amp;rng, R rel=R{}, P proj=P{})</td></tr>
<tr class="separator:ga8947a9b8ad8f366f3603012c4a2ef0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b00fc4c00eebb280fb24a50aa8517af"><td class="memItemLeft" align="right" valign="top"><a id="ga3b00fc4c00eebb280fb24a50aa8517af"></a>
I AND constexpr indirect_strict_weak_order&lt; R, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_sorted_until</b> (I first, <a class="el" href="structS.html">S</a> last, R <a class="el" href="structpred.html">pred</a>=R{}, P proj=P{})</td></tr>
<tr class="separator:ga3b00fc4c00eebb280fb24a50aa8517af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd306f885c882df803432147c65e11bd"><td class="memItemLeft" align="right" valign="top"><a id="gacd306f885c882df803432147c65e11bd"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::is_sorted_until</b> (Rng &amp;&amp;rng, R <a class="el" href="structpred.html">pred</a>=R{}, P proj=P{})</td></tr>
<tr class="separator:gacd306f885c882df803432147c65e11bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa79b095a3df173c8c75f7df516efc672"><td class="memItemLeft" align="right" valign="top"><a id="gaa79b095a3df173c8c75f7df516efc672"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa79b095a3df173c8c75f7df516efc672">ranges::template</a> (typename I0, typename S0, typename I1, typename S1, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I0 &gt; AND sentinel_for&lt; S0</td></tr>
<tr class="memdesc:gaa79b095a3df173c8c75f7df516efc672"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>lexicographical_compare</code> <br /></td></tr>
<tr class="separator:gaa79b095a3df173c8c75f7df516efc672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097f7e5b7169d3b48c5b6e0bb1c2ee5c"><td class="memItemLeft" align="right" valign="top"><a id="ga097f7e5b7169d3b48c5b6e0bb1c2ee5c"></a>
I0 AND input_iterator&lt; I1 &gt; AND sentinel_for&lt; S1, I1 &gt; AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::lexicographical_compare</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga097f7e5b7169d3b48c5b6e0bb1c2ee5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d927cf30e3831ac3977c9c48e07b20"><td class="memItemLeft" align="right" valign="top"><a id="ga66d927cf30e3831ac3977c9c48e07b20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga66d927cf30e3831ac3977c9c48e07b20">ranges::template</a> (typename Rng0, typename Rng1, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng0 &gt; AND input_range&lt; Rng1 &gt; AND indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:ga66d927cf30e3831ac3977c9c48e07b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga66d927cf30e3831ac3977c9c48e07b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338b72e6f37a9860f9ad351fb2e475a6"><td class="memItemLeft" align="right" valign="top"><a id="ga338b72e6f37a9860f9ad351fb2e475a6"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;, P1 &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::lexicographical_compare</b> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga338b72e6f37a9860f9ad351fb2e475a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21b289da02634398457c30f8baf894f"><td class="memItemLeft" align="right" valign="top"><a id="gae21b289da02634398457c30f8baf894f"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, V const *, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::lower_bound</b> (I first, <a class="el" href="structS.html">S</a> last, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gae21b289da02634398457c30f8baf894f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga636210117d44d47fe5afc01fa1c538a7"><td class="memItemLeft" align="right" valign="top"><a id="ga636210117d44d47fe5afc01fa1c538a7"></a>
V const constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::lower_bound</b> (Rng &amp;&amp;rng, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga636210117d44d47fe5afc01fa1c538a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb022dc39b16e3ff52a3537e3c205bc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaeb022dc39b16e3ff52a3537e3c205bc8">ranges::template</a> (typename <a class="el" href="structT.html">T</a>, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:gaeb022dc39b16e3ff52a3537e3c205bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>max</code>  <a href="group__group-algorithms.html#gaeb022dc39b16e3ff52a3537e3c205bc8">More...</a><br /></td></tr>
<tr class="separator:gaeb022dc39b16e3ff52a3537e3c205bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7f5950eadebe9637b76d3a55d5d5fd"><td class="memItemLeft" align="right" valign="top"><a id="ga7e7f5950eadebe9637b76d3a55d5d5fd"></a>
constexpr projected&lt; <a class="el" href="structT.html">T</a> const *, P &gt; <a class="el" href="structT.html">T</a> const  &amp;RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::max</b> (<a class="el" href="structT.html">T</a> const &amp;a, <a class="el" href="structT.html">T</a> const &amp;b, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga7e7f5950eadebe9637b76d3a55d5d5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318673a42b7e859822bd8a67296dabe1"><td class="memItemLeft" align="right" valign="top"><a id="ga318673a42b7e859822bd8a67296dabe1"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND constexpr indirectly_copyable_storable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, range_value_t&lt; Rng &gt; * &gt; range_value_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::max</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga318673a42b7e859822bd8a67296dabe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897b78a37d9e09933525c3f2f3c35460"><td class="memItemLeft" align="right" valign="top"><a id="ga897b78a37d9e09933525c3f2f3c35460"></a>
constexpr projected&lt; <a class="el" href="structT.html">T</a> const *, P &gt; <a class="el" href="structT.html">T</a> RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::max</b> (std::initializer_list&lt; <a class="el" href="structT.html">T</a> &gt; const &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga897b78a37d9e09933525c3f2f3c35460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4bd66fbb16952516e539252ae4a7e52"><td class="memItemLeft" align="right" valign="top"><a id="gad4bd66fbb16952516e539252ae4a7e52"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::max_element</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gad4bd66fbb16952516e539252ae4a7e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797f6636195b33b4cc3a4cc357917f5f"><td class="memItemLeft" align="right" valign="top"><a id="ga797f6636195b33b4cc3a4cc357917f5f"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::max_element</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga797f6636195b33b4cc3a4cc357917f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa31f98bc48004e5be4324d8d9fce087"><td class="memItemLeft" align="right" valign="top"><a id="gafa31f98bc48004e5be4324d8d9fce087"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafa31f98bc48004e5be4324d8d9fce087">ranges::template</a> (typename I0, typename S0, typename I1, typename S1, typename O, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires sentinel_for&lt; S0</td></tr>
<tr class="memdesc:gafa31f98bc48004e5be4324d8d9fce087"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>merge</code> <br /></td></tr>
<tr class="separator:gafa31f98bc48004e5be4324d8d9fce087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b7d33b2500267d345213761b7f1e41"><td class="memItemLeft" align="right" valign="top"><a id="gad8b7d33b2500267d345213761b7f1e41"></a>
I0 AND sentinel_for&lt; S1, I1 &gt; AND constexpr mergeable&lt; I0, I1, O, <a class="el" href="classC.html">C</a>, P0, P1 &gt; merge_result&lt; I0, I1, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::merge</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:gad8b7d33b2500267d345213761b7f1e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga489661a8737a3784ec6206155558ab72"><td class="memItemLeft" align="right" valign="top"><a id="ga489661a8737a3784ec6206155558ab72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga489661a8737a3784ec6206155558ab72">ranges::template</a> (typename Rng0, typename Rng1, typename O, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires range&lt; Rng0 &gt; AND range&lt; Rng1 &gt; AND mergeable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng0 &gt;</td></tr>
<tr class="memdesc:ga489661a8737a3784ec6206155558ab72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga489661a8737a3784ec6206155558ab72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2f1312c1286771ab9620828660db80"><td class="memItemLeft" align="right" valign="top"><a id="gadb2f1312c1286771ab9620828660db80"></a>
constexpr P1 merge_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, borrowed_iterator_t&lt; Rng1 &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::merge</b> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:gadb2f1312c1286771ab9620828660db80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354cd4941994626152ccb1e9ab9722b4"><td class="memItemLeft" align="right" valign="top"><a id="ga354cd4941994626152ccb1e9ab9722b4"></a>
constexpr projected&lt; <a class="el" href="structT.html">T</a> const *, P &gt; <a class="el" href="structT.html">T</a> const  &amp;RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::min</b> (<a class="el" href="structT.html">T</a> const &amp;a, <a class="el" href="structT.html">T</a> const &amp;b, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga354cd4941994626152ccb1e9ab9722b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d8de0c8b04a38075d49a8686bf9a57a"><td class="memItemLeft" align="right" valign="top"><a id="ga0d8de0c8b04a38075d49a8686bf9a57a"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND constexpr indirectly_copyable_storable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, range_value_t&lt; Rng &gt; * &gt; range_value_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::min</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga0d8de0c8b04a38075d49a8686bf9a57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac25ca020c88d92b7a13615a91f79ab7a"><td class="memItemLeft" align="right" valign="top"><a id="gac25ca020c88d92b7a13615a91f79ab7a"></a>
constexpr projected&lt; <a class="el" href="structT.html">T</a> const *, P &gt; <a class="el" href="structT.html">T</a> RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::min</b> (std::initializer_list&lt; <a class="el" href="structT.html">T</a> &gt; const &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gac25ca020c88d92b7a13615a91f79ab7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563f536c026be36518418e71ca3101dd"><td class="memItemLeft" align="right" valign="top"><a id="ga563f536c026be36518418e71ca3101dd"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::min_element</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga563f536c026be36518418e71ca3101dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18036cd5f54603df7fb972fde7d5ef06"><td class="memItemLeft" align="right" valign="top"><a id="ga18036cd5f54603df7fb972fde7d5ef06"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::min_element</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga18036cd5f54603df7fb972fde7d5ef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b968e545ae194ae10cee22c16425ffc"><td class="memItemLeft" align="right" valign="top"><a id="ga7b968e545ae194ae10cee22c16425ffc"></a>
constexpr projected&lt; <a class="el" href="structT.html">T</a> const *, P &gt; minmax_result&lt; <a class="el" href="structT.html">T</a> const &amp; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::minmax</b> (<a class="el" href="structT.html">T</a> const &amp;a, <a class="el" href="structT.html">T</a> const &amp;b, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga7b968e545ae194ae10cee22c16425ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabba99589b6c02743450231abdef8b55e"><td class="memItemLeft" align="right" valign="top"><a id="gabba99589b6c02743450231abdef8b55e"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND constexpr indirectly_copyable_storable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, range_value_t&lt; Rng &gt; * &gt; minmax_result&lt; range_value_t&lt; Rng &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::minmax</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gabba99589b6c02743450231abdef8b55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc664563ab47eaacc56744f7238e243"><td class="memItemLeft" align="right" valign="top"><a id="gaabc664563ab47eaacc56744f7238e243"></a>
constexpr projected&lt; <a class="el" href="structT.html">T</a> const *, P &gt; minmax_result&lt; <a class="el" href="structT.html">T</a> &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::minmax</b> (std::initializer_list&lt; <a class="el" href="structT.html">T</a> &gt; const &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaabc664563ab47eaacc56744f7238e243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c5bc2c946d8d26cc31ac9e49923937"><td class="memItemLeft" align="right" valign="top"><a id="gaf3c5bc2c946d8d26cc31ac9e49923937"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; minmax_element_result&lt; I &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::minmax_element</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaf3c5bc2c946d8d26cc31ac9e49923937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23344e65f007b7aeb54e777985af206"><td class="memItemLeft" align="right" valign="top"><a id="gae23344e65f007b7aeb54e777985af206"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; minmax_element_result&lt; borrowed_iterator_t&lt; Rng &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::minmax_element</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gae23344e65f007b7aeb54e777985af206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7478ecfb8054880ee4ccb9181fba8eba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7478ecfb8054880ee4ccb9181fba8eba">ranges::template</a> (typename I1, typename S1, typename I2, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I1 &gt; AND sentinel_for&lt; S1</td></tr>
<tr class="memdesc:ga7478ecfb8054880ee4ccb9181fba8eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>mismatch</code>  <a href="group__group-algorithms.html#ga7478ecfb8054880ee4ccb9181fba8eba">More...</a><br /></td></tr>
<tr class="separator:ga7478ecfb8054880ee4ccb9181fba8eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a57bcb3ea124bd9927f36ec86ff7e38"><td class="memItemLeft" align="right" valign="top"><a id="ga4a57bcb3ea124bd9927f36ec86ff7e38"></a>
I1 AND input_iterator&lt; I2 &gt; AND indirect_relation&lt; <a class="el" href="classC.html">C</a>, projected&lt; I1, P1 &gt;, projected&lt; I2, P2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::RANGES_DEPRECATED</b> (&quot;Use the <a class="el" href="structranges_1_1variant.html">variant</a> of ranges::mismatch that takes an upper bound for &quot; &quot;both sequences&quot;) mismatch_result&lt; I1</td></tr>
<tr class="separator:ga4a57bcb3ea124bd9927f36ec86ff7e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ecc87fe6e007a8f3e12a1236be1fc6a"><td class="memItemLeft" align="right" valign="top"><a id="ga4ecc87fe6e007a8f3e12a1236be1fc6a"></a>
I1 AND input_iterator&lt; I2 &gt; AND indirect_relation&lt; <a class="el" href="classC.html">C</a>, projected&lt; I1, P1 &gt;, projected&lt; I2, P2 &gt; &gt; I2 RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::mismatch</b> (I1 begin1, S1 end1, I2 begin2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga4ecc87fe6e007a8f3e12a1236be1fc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a3ebd3a1fa3847fe6e195ae39a95c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga88a3ebd3a1fa3847fe6e195ae39a95c2">ranges::template</a> (typename I1, typename S1, typename I2, typename S2, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I1 &gt; AND sentinel_for&lt; S1</td></tr>
<tr class="memdesc:ga88a3ebd3a1fa3847fe6e195ae39a95c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-algorithms.html#ga88a3ebd3a1fa3847fe6e195ae39a95c2">More...</a><br /></td></tr>
<tr class="separator:ga88a3ebd3a1fa3847fe6e195ae39a95c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1337756312d112d5d1d9f16c0cf25dfb"><td class="memItemLeft" align="right" valign="top"><a id="ga1337756312d112d5d1d9f16c0cf25dfb"></a>
I1 AND input_iterator&lt; I2 &gt; AND sentinel_for&lt; S2, I2 &gt; AND constexpr indirect_relation&lt; <a class="el" href="classC.html">C</a>, projected&lt; I1, P1 &gt;, projected&lt; I2, P2 &gt; &gt; mismatch_result&lt; I1, I2 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::mismatch</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga1337756312d112d5d1d9f16c0cf25dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87df4e152df645625fdf0e6134b3f566"><td class="memItemLeft" align="right" valign="top"><a id="ga87df4e152df645625fdf0e6134b3f566"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga87df4e152df645625fdf0e6134b3f566">ranges::template</a> (typename Rng1, typename I2Ref, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng1 &gt; AND input_iterator&lt; uncvref_t&lt; I2Ref &gt;&gt; AND indirect_relation&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:ga87df4e152df645625fdf0e6134b3f566"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga87df4e152df645625fdf0e6134b3f566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3de2cf9956cdef31d6194bd1a809321"><td class="memItemLeft" align="right" valign="top"><a id="gad3de2cf9956cdef31d6194bd1a809321"></a>
projected&lt; uncvref_t&lt; I2Ref &gt;, P2 &gt; uncvref_t&lt; I2Ref &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::mismatch</b> (Rng1 &amp;&amp;rng1, I2Ref &amp;&amp;begin2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:gad3de2cf9956cdef31d6194bd1a809321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64f2a1bb33c316118c3fb1417ce7357"><td class="memItemLeft" align="right" valign="top"><a id="gae64f2a1bb33c316118c3fb1417ce7357"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae64f2a1bb33c316118c3fb1417ce7357">ranges::template</a> (typename Rng1, typename Rng2, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng1 &gt; AND input_range&lt; Rng2 &gt; AND indirect_relation&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:gae64f2a1bb33c316118c3fb1417ce7357"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gae64f2a1bb33c316118c3fb1417ce7357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5395f0e0b75d6598de5dc619b6f545e7"><td class="memItemLeft" align="right" valign="top"><a id="ga5395f0e0b75d6598de5dc619b6f545e7"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng2 &gt;, P2 &gt; mismatch_result&lt; borrowed_iterator_t&lt; Rng1 &gt;, borrowed_iterator_t&lt; Rng2 &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::mismatch</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga5395f0e0b75d6598de5dc619b6f545e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c0879fba187804e20fd30194d0cd2d"><td class="memItemLeft" align="right" valign="top"><a id="ga61c0879fba187804e20fd30194d0cd2d"></a>
I AND weakly_incrementable&lt; O &gt; AND constexpr indirectly_movable&lt; I, O &gt; move_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::move</b> (I first, <a class="el" href="structS.html">S</a> last, O out)</td></tr>
<tr class="separator:ga61c0879fba187804e20fd30194d0cd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga244741eb401bea36b0b29867883c1132"><td class="memItemLeft" align="right" valign="top"><a id="ga244741eb401bea36b0b29867883c1132"></a>
constexpr O move_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::move</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="separator:ga244741eb401bea36b0b29867883c1132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bca8e48d608759ebfcf0e0cd706646d"><td class="memItemLeft" align="right" valign="top"><a id="ga5bca8e48d608759ebfcf0e0cd706646d"></a>
I AND bidirectional_iterator&lt; O &gt; AND constexpr indirectly_movable&lt; I, O &gt; move_backward_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::move_backward</b> (I first, <a class="el" href="structS.html">S</a> end_, O out)</td></tr>
<tr class="separator:ga5bca8e48d608759ebfcf0e0cd706646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbb21c14cb2a19502aa709d66f11ac0"><td class="memItemLeft" align="right" valign="top"><a id="ga3bbb21c14cb2a19502aa709d66f11ac0"></a>
constexpr O move_backward_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::move_backward</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="separator:ga3bbb21c14cb2a19502aa709d66f11ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a28f76fe439844a2c97e0c7d3664dad"><td class="memItemLeft" align="right" valign="top"><a id="ga4a28f76fe439844a2c97e0c7d3664dad"></a>
I AND constexpr indirect_unary_predicate&lt; F, projected&lt; I, P &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::none_of</b> (I first, <a class="el" href="structS.html">S</a> last, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga4a28f76fe439844a2c97e0c7d3664dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf961505116e54cbbf029913007864f7e"><td class="memItemLeft" align="right" valign="top"><a id="gaf961505116e54cbbf029913007864f7e"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::none_of</b> (Rng &amp;&amp;rng, F <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gaf961505116e54cbbf029913007864f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb11fd0a2c7ff9a7b09926bff4fe8a8"><td class="memItemLeft" align="right" valign="top"><a id="ga1cb11fd0a2c7ff9a7b09926bff4fe8a8"></a>
constexpr P I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::nth_element</b> (I first, I nth, <a class="el" href="structS.html">S</a> end_, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga1cb11fd0a2c7ff9a7b09926bff4fe8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7961249e39b4b07eb9d51c5fdbe100"><td class="memItemLeft" align="right" valign="top"><a id="ga6b7961249e39b4b07eb9d51c5fdbe100"></a>
constexpr P borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::nth_element</b> (Rng &amp;&amp;rng, <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; nth, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga6b7961249e39b4b07eb9d51c5fdbe100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3f33b0a0c9bef134ed4dfbce1be934"><td class="memItemLeft" align="right" valign="top"><a id="ga8f3f33b0a0c9bef134ed4dfbce1be934"></a>
P AND random_access_iterator&lt; I &gt; AND constexpr sentinel_for&lt; <a class="el" href="structS.html">S</a>, I &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partial_sort</b> (I first, I middle, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga8f3f33b0a0c9bef134ed4dfbce1be934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9361eeaaa44609e02d525503a25f81"><td class="memItemLeft" align="right" valign="top"><a id="ga2d9361eeaaa44609e02d525503a25f81"></a>
P AND constexpr random_access_range&lt; Rng &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partial_sort</b> (Rng &amp;&amp;rng, <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; middle, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga2d9361eeaaa44609e02d525503a25f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c9ba1d6189f82fc3770aff39a8192d"><td class="memItemLeft" align="right" valign="top"><a id="ga41c9ba1d6189f82fc3770aff39a8192d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga41c9ba1d6189f82fc3770aff39a8192d">ranges::template</a> (typename I, typename SI, typename O, typename SO, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename PI=<a class="el" href="structranges_1_1identity.html">identity</a>, typename PO=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; SI</td></tr>
<tr class="memdesc:ga41c9ba1d6189f82fc3770aff39a8192d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partial_sort_copy</code> <br /></td></tr>
<tr class="separator:ga41c9ba1d6189f82fc3770aff39a8192d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649047467fd8bc73b09c1ef18ecb2595"><td class="memItemLeft" align="right" valign="top"><a id="ga649047467fd8bc73b09c1ef18ecb2595"></a>
I AND random_access_iterator&lt; O &gt; AND sentinel_for&lt; SO, O &gt; AND indirectly_copyable&lt; I, O &gt; AND sortable&lt; O, <a class="el" href="classC.html">C</a>, PO &gt; AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, PI &gt;, projected&lt; O, PO &gt; &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partial_sort_copy</b> (I first, SI last, O out_begin, SO out_end, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, PI in_proj=PI{}, PO out_proj=PO{})</td></tr>
<tr class="separator:ga649047467fd8bc73b09c1ef18ecb2595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82fc52dd7da58e37cf5e379f0086bd8"><td class="memItemLeft" align="right" valign="top"><a id="gad82fc52dd7da58e37cf5e379f0086bd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad82fc52dd7da58e37cf5e379f0086bd8">ranges::template</a> (typename InRng, typename OutRng, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename PI=<a class="el" href="structranges_1_1identity.html">identity</a>, typename PO=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; InRng &gt; AND random_access_range&lt; OutRng &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; InRng &gt;</td></tr>
<tr class="memdesc:gad82fc52dd7da58e37cf5e379f0086bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gad82fc52dd7da58e37cf5e379f0086bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5959978467189f1f33cba119c2470fba"><td class="memItemLeft" align="right" valign="top"><a id="ga5959978467189f1f33cba119c2470fba"></a>
<a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; OutRng &gt; AND sortable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; OutRng &gt;, <a class="el" href="classC.html">C</a>, PO &gt; AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; InRng &gt;, PI &gt;, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; OutRng &gt;, PO &gt; &gt; borrowed_iterator_t&lt; OutRng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partial_sort_copy</b> (InRng &amp;&amp;in_rng, OutRng &amp;&amp;out_rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, PI in_proj=PI{}, PO out_proj=PO{})</td></tr>
<tr class="separator:ga5959978467189f1f33cba119c2470fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103adb70009a1a2450fac907b451254d"><td class="memItemLeft" align="right" valign="top"><a id="ga103adb70009a1a2450fac907b451254d"></a>
I AND constexpr indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partition</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga103adb70009a1a2450fac907b451254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c547681d9048c260985baadfde0a0f"><td class="memItemLeft" align="right" valign="top"><a id="ga49c547681d9048c260985baadfde0a0f"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partition</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga49c547681d9048c260985baadfde0a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ee520e1bddc11ba453a13fca40e118"><td class="memItemLeft" align="right" valign="top"><a id="ga92ee520e1bddc11ba453a13fca40e118"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga92ee520e1bddc11ba453a13fca40e118">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O0, typename O1, typename <a class="el" href="classC.html">C</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga92ee520e1bddc11ba453a13fca40e118"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition_copy</code> <br /></td></tr>
<tr class="separator:ga92ee520e1bddc11ba453a13fca40e118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262323b8ca646fd10a49f04be82f4185"><td class="memItemLeft" align="right" valign="top"><a id="ga262323b8ca646fd10a49f04be82f4185"></a>
I AND weakly_incrementable&lt; O0 &gt; AND weakly_incrementable&lt; O1 &gt; AND indirectly_copyable&lt; I, O0 &gt; AND indirectly_copyable&lt; I, O1 &gt; AND constexpr indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; partition_copy_result&lt; I, O0, O1 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partition_copy</b> (I first, <a class="el" href="structS.html">S</a> last, O0 o0, O1 o1, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga262323b8ca646fd10a49f04be82f4185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125c3233656415fc3e8cea56df1e5357"><td class="memItemLeft" align="right" valign="top"><a id="ga125c3233656415fc3e8cea56df1e5357"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga125c3233656415fc3e8cea56df1e5357">ranges::template</a> (typename Rng, typename O0, typename O1, typename <a class="el" href="classC.html">C</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND weakly_incrementable&lt; O0 &gt; AND weakly_incrementable&lt; O1 &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;</td></tr>
<tr class="memdesc:ga125c3233656415fc3e8cea56df1e5357"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga125c3233656415fc3e8cea56df1e5357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e50654e7ee3d1d4cc107e613b8d9892"><td class="memItemLeft" align="right" valign="top"><a id="ga8e50654e7ee3d1d4cc107e613b8d9892"></a>
O0 AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O1 &gt; AND constexpr indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; &gt; partition_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O0, O1 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partition_copy</b> (Rng &amp;&amp;rng, O0 o0, O1 o1, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga8e50654e7ee3d1d4cc107e613b8d9892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15dd897df6fd3ff8b9c536959fb2b0cb"><td class="memItemLeft" align="right" valign="top"><a id="ga15dd897df6fd3ff8b9c536959fb2b0cb"></a>
I AND constexpr indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partition_point</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga15dd897df6fd3ff8b9c536959fb2b0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b82474d78f1ddccb1665be9f4207f1c"><td class="memItemLeft" align="right" valign="top"><a id="ga5b82474d78f1ddccb1665be9f4207f1c"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::partition_point</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga5b82474d78f1ddccb1665be9f4207f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61dfb578761883ed7d9abfc9a00e66ab"><td class="memItemLeft" align="right" valign="top"><a id="ga61dfb578761883ed7d9abfc9a00e66ab"></a>
I1 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I2 &gt; AND indirectly_comparable&lt; I1, I2, <a class="el" href="classC.html">C</a>, P1, P2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::RANGES_DEPRECATED</b> (&quot;Use the <a class="el" href="structranges_1_1variant.html">variant</a> of ranges::is_permutation that takes an upper bound &quot; &quot;for both sequences&quot;) bool RANGES_FUNC(is_permutation)(I1 begin1</td></tr>
<tr class="separator:ga61dfb578761883ed7d9abfc9a00e66ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c9ba9284e64db0f185f3777d1909f7"><td class="memItemLeft" align="right" valign="top"><a id="ga87c9ba9284e64db0f185f3777d1909f7"></a>
I AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, <a class="el" href="structT.html">T</a> const * &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="structT.html">T</a> const &amp;val, P proj=P{})</td></tr>
<tr class="separator:ga87c9ba9284e64db0f185f3777d1909f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ab0e59ed26839a81139c79f1a57d59"><td class="memItemLeft" align="right" valign="top"><a id="ga91ab0e59ed26839a81139c79f1a57d59"></a>
<a class="el" href="structT.html">T</a> const  *constexpr borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove</b> (Rng &amp;&amp;rng, <a class="el" href="structT.html">T</a> const &amp;val, P proj=P{})</td></tr>
<tr class="separator:ga91ab0e59ed26839a81139c79f1a57d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5e566759641119cbf5312cde7d9aee"><td class="memItemLeft" align="right" valign="top"><a id="gadf5e566759641119cbf5312cde7d9aee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gadf5e566759641119cbf5312cde7d9aee">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gadf5e566759641119cbf5312cde7d9aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy</code> <br /></td></tr>
<tr class="separator:gadf5e566759641119cbf5312cde7d9aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5fba4f0c7e963f6031c136da64d2f2e"><td class="memItemLeft" align="right" valign="top"><a id="gad5fba4f0c7e963f6031c136da64d2f2e"></a>
I AND weakly_incrementable&lt; O &gt; AND indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, <a class="el" href="structT.html">T</a> const * &gt; AND constexpr indirectly_copyable&lt; I, O &gt; remove_copy_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove_copy</b> (I first, <a class="el" href="structS.html">S</a> last, O out, <a class="el" href="structT.html">T</a> const &amp;val, P proj=P{})</td></tr>
<tr class="separator:gad5fba4f0c7e963f6031c136da64d2f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3e97709c81cb85352cd7e1b93db149"><td class="memItemLeft" align="right" valign="top"><a id="ga7a3e97709c81cb85352cd7e1b93db149"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7a3e97709c81cb85352cd7e1b93db149">ranges::template</a> (typename Rng, typename O, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND weakly_incrementable&lt; O &gt; AND indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:ga7a3e97709c81cb85352cd7e1b93db149"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga7a3e97709c81cb85352cd7e1b93db149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dcf9a1eea483e8ede9027983faa736a"><td class="memItemLeft" align="right" valign="top"><a id="ga8dcf9a1eea483e8ede9027983faa736a"></a>
<a class="el" href="structT.html">T</a> const  *AND constexpr indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt; remove_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove_copy</b> (Rng &amp;&amp;rng, O out, <a class="el" href="structT.html">T</a> const &amp;val, P proj=P{})</td></tr>
<tr class="separator:ga8dcf9a1eea483e8ede9027983faa736a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd80fd05cd628279b02c31818cf16ec5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gadd80fd05cd628279b02c31818cf16ec5">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O, typename <a class="el" href="classC.html">C</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gadd80fd05cd628279b02c31818cf16ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy_if</code>  <a href="group__group-algorithms.html#gadd80fd05cd628279b02c31818cf16ec5">More...</a><br /></td></tr>
<tr class="separator:gadd80fd05cd628279b02c31818cf16ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fddb637a8cc69b3999bb2a540d51ab8"><td class="memItemLeft" align="right" valign="top"><a id="ga4fddb637a8cc69b3999bb2a540d51ab8"></a>
I AND weakly_incrementable&lt; O &gt; AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; AND constexpr indirectly_copyable&lt; I, O &gt; remove_copy_if_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove_copy_if</b> (I first, <a class="el" href="structS.html">S</a> last, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga4fddb637a8cc69b3999bb2a540d51ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd216ecd4965f1a119faef91f8e718d"><td class="memItemLeft" align="right" valign="top"><a id="ga3bd216ecd4965f1a119faef91f8e718d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga3bd216ecd4965f1a119faef91f8e718d">ranges::template</a> (typename Rng, typename O, typename <a class="el" href="classC.html">C</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND weakly_incrementable&lt; O &gt; AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:ga3bd216ecd4965f1a119faef91f8e718d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3bd216ecd4965f1a119faef91f8e718d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed41b279a1d7e807ab5684233889952"><td class="memItemLeft" align="right" valign="top"><a id="ga2ed41b279a1d7e807ab5684233889952"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND constexpr indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt; remove_copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove_copy_if</b> (Rng &amp;&amp;rng, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga2ed41b279a1d7e807ab5684233889952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b2845b1986b71c03b7ca514c585cb3"><td class="memItemLeft" align="right" valign="top"><a id="ga06b2845b1986b71c03b7ca514c585cb3"></a>
I AND constexpr indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove_if</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga06b2845b1986b71c03b7ca514c585cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7909454afa46b76b30ded86d11a187"><td class="memItemLeft" align="right" valign="top"><a id="gace7909454afa46b76b30ded86d11a187"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::remove_if</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:gace7909454afa46b76b30ded86d11a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902776614d9f7238a2a5d86ccddc8693"><td class="memItemLeft" align="right" valign="top"><a id="ga902776614d9f7238a2a5d86ccddc8693"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga902776614d9f7238a2a5d86ccddc8693">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename T1, typename T2, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga902776614d9f7238a2a5d86ccddc8693"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace</code> <br /></td></tr>
<tr class="separator:ga902776614d9f7238a2a5d86ccddc8693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a64ed2aed3e50a08ec31fa19d1bcbc0"><td class="memItemLeft" align="right" valign="top"><a id="ga8a64ed2aed3e50a08ec31fa19d1bcbc0"></a>
I AND indirectly_writable&lt; I, T2 const &amp; &gt; AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, T1 const * &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace</b> (I first, <a class="el" href="structS.html">S</a> last, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="separator:ga8a64ed2aed3e50a08ec31fa19d1bcbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d00878c7f6cf0d7380d322863ee739f"><td class="memItemLeft" align="right" valign="top"><a id="ga6d00878c7f6cf0d7380d322863ee739f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga6d00878c7f6cf0d7380d322863ee739f">ranges::template</a> (typename Rng, typename T1, typename T2, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND indirectly_writable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;</td></tr>
<tr class="memdesc:ga6d00878c7f6cf0d7380d322863ee739f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga6d00878c7f6cf0d7380d322863ee739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga823aed4a2c73b80d1a67a2dc9bde73b0"><td class="memItemLeft" align="right" valign="top"><a id="ga823aed4a2c73b80d1a67a2dc9bde73b0"></a>
T2 const  &amp;AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt;, T1 const * &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace</b> (Rng &amp;&amp;rng, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="separator:ga823aed4a2c73b80d1a67a2dc9bde73b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c66a62ed7aa440c8daa5d7a2ecabf4"><td class="memItemLeft" align="right" valign="top"><a id="gae0c66a62ed7aa440c8daa5d7a2ecabf4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae0c66a62ed7aa440c8daa5d7a2ecabf4">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O, typename T1, typename T2, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gae0c66a62ed7aa440c8daa5d7a2ecabf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy</code> <br /></td></tr>
<tr class="separator:gae0c66a62ed7aa440c8daa5d7a2ecabf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d337f58ada908ab4f22590826f2ad9"><td class="memItemLeft" align="right" valign="top"><a id="ga29d337f58ada908ab4f22590826f2ad9"></a>
I AND output_iterator&lt; O, T2 const &amp; &gt; AND indirectly_copyable&lt; I, O &gt; AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, T1 const * &gt; replace_copy_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace_copy</b> (I first, <a class="el" href="structS.html">S</a> last, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="separator:ga29d337f58ada908ab4f22590826f2ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e7535ca9773609acbca874f97ad24a"><td class="memItemLeft" align="right" valign="top"><a id="ga78e7535ca9773609acbca874f97ad24a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga78e7535ca9773609acbca874f97ad24a">ranges::template</a> (typename Rng, typename O, typename T1, typename T2, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND output_iterator&lt; O</td></tr>
<tr class="memdesc:ga78e7535ca9773609acbca874f97ad24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga78e7535ca9773609acbca874f97ad24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e377690551d8dbc1f746ae1f4ac1371"><td class="memItemLeft" align="right" valign="top"><a id="ga7e377690551d8dbc1f746ae1f4ac1371"></a>
T2 const  &amp;AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt; AND constexpr indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt;, T1 const * &gt; replace_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace_copy</b> (Rng &amp;&amp;rng, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="separator:ga7e377690551d8dbc1f746ae1f4ac1371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5318457e904be2aa8ac584540ce99162"><td class="memItemLeft" align="right" valign="top"><a id="ga5318457e904be2aa8ac584540ce99162"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5318457e904be2aa8ac584540ce99162">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O, typename <a class="el" href="classC.html">C</a>, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga5318457e904be2aa8ac584540ce99162"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy_if</code> <br /></td></tr>
<tr class="separator:ga5318457e904be2aa8ac584540ce99162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6209789ede0f0bfa22cf3da2fe488a5a"><td class="memItemLeft" align="right" valign="top"><a id="ga6209789ede0f0bfa22cf3da2fe488a5a"></a>
I AND output_iterator&lt; O, <a class="el" href="structT.html">T</a> const &amp; &gt; AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; AND constexpr indirectly_copyable&lt; I, O &gt; replace_copy_if_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace_copy_if</b> (I first, <a class="el" href="structS.html">S</a> last, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, <a class="el" href="structT.html">T</a> const &amp;new_value, P proj={})</td></tr>
<tr class="separator:ga6209789ede0f0bfa22cf3da2fe488a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb98225e4550c187dcb6d6813f037422"><td class="memItemLeft" align="right" valign="top"><a id="gadb98225e4550c187dcb6d6813f037422"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gadb98225e4550c187dcb6d6813f037422">ranges::template</a> (typename Rng, typename O, typename <a class="el" href="classC.html">C</a>, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND output_iterator&lt; O</td></tr>
<tr class="memdesc:gadb98225e4550c187dcb6d6813f037422"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gadb98225e4550c187dcb6d6813f037422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4281b9c40d340ddc605c22a2df0912d"><td class="memItemLeft" align="right" valign="top"><a id="gab4281b9c40d340ddc605c22a2df0912d"></a>
<a class="el" href="structT.html">T</a> const  &amp;AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; &gt; AND constexpr indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt; replace_copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace_copy_if</b> (Rng &amp;&amp;rng, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, <a class="el" href="structT.html">T</a> const &amp;new_value, P proj={})</td></tr>
<tr class="separator:gab4281b9c40d340ddc605c22a2df0912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad07ab37234f29c3ea38304024a5b57c"><td class="memItemLeft" align="right" valign="top"><a id="gaad07ab37234f29c3ea38304024a5b57c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaad07ab37234f29c3ea38304024a5b57c">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename <a class="el" href="classC.html">C</a>, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gaad07ab37234f29c3ea38304024a5b57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_if</code> <br /></td></tr>
<tr class="separator:gaad07ab37234f29c3ea38304024a5b57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896381e57028e125353a3e02e060e8ae"><td class="memItemLeft" align="right" valign="top"><a id="ga896381e57028e125353a3e02e060e8ae"></a>
I AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; AND constexpr indirectly_writable&lt; I, <a class="el" href="structT.html">T</a> const &amp; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace_if</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, <a class="el" href="structT.html">T</a> const &amp;new_value, P proj=P{})</td></tr>
<tr class="separator:ga896381e57028e125353a3e02e060e8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d91ce13fe0746b5eee5a6f2b7ee6fc1"><td class="memItemLeft" align="right" valign="top"><a id="ga1d91ce13fe0746b5eee5a6f2b7ee6fc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1d91ce13fe0746b5eee5a6f2b7ee6fc1">ranges::template</a> (typename Rng, typename <a class="el" href="classC.html">C</a>, typename <a class="el" href="structT.html">T</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng &gt; AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:ga1d91ce13fe0746b5eee5a6f2b7ee6fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga1d91ce13fe0746b5eee5a6f2b7ee6fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab309b1b561e19d9830b47993500910a4"><td class="memItemLeft" align="right" valign="top"><a id="gab309b1b561e19d9830b47993500910a4"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND constexpr indirectly_writable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, <a class="el" href="structT.html">T</a> const &amp; &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::replace_if</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, <a class="el" href="structT.html">T</a> const &amp;new_value, P proj=P{})</td></tr>
<tr class="separator:gab309b1b561e19d9830b47993500910a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22168919ab36c29ff99b10469878874b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga22168919ab36c29ff99b10469878874b">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>)(requires bidirectional_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga22168919ab36c29ff99b10469878874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>reverse</code>  <a href="group__group-algorithms.html#ga22168919ab36c29ff99b10469878874b">More...</a><br /></td></tr>
<tr class="separator:ga22168919ab36c29ff99b10469878874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5c7dff5e591b19432d421997a92b3f"><td class="memItemLeft" align="right" valign="top"><a id="gaff5c7dff5e591b19432d421997a92b3f"></a>
I AND constexpr permutable&lt; I &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::reverse</b> (I first, <a class="el" href="structS.html">S</a> end_)</td></tr>
<tr class="separator:gaff5c7dff5e591b19432d421997a92b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1601d4b1686294e3249518c1beda8104"><td class="memItemLeft" align="right" valign="top"><a id="ga1601d4b1686294e3249518c1beda8104"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1601d4b1686294e3249518c1beda8104">ranges::template</a> (typename Rng, typename I=<a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;)(requires bidirectional_range&lt; Rng &gt; AND permutable&lt; I &gt;) const expr borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC(reverse)(Rng &amp;&amp;rng)</td></tr>
<tr class="memdesc:ga1601d4b1686294e3249518c1beda8104"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga1601d4b1686294e3249518c1beda8104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44b41b85f3c241278c30f697a0bd51e"><td class="memItemLeft" align="right" valign="top"><a id="gac44b41b85f3c241278c30f697a0bd51e"></a>
I AND weakly_incrementable&lt; O &gt; AND constexpr indirectly_copyable&lt; I, O &gt; reverse_copy_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::reverse_copy</b> (I first, <a class="el" href="structS.html">S</a> end_, O out)</td></tr>
<tr class="separator:gac44b41b85f3c241278c30f697a0bd51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703f1f9c8c8211c8697987d6968f8a22"><td class="memItemLeft" align="right" valign="top"><a id="ga703f1f9c8c8211c8697987d6968f8a22"></a>
constexpr O reverse_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::reverse_copy</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="separator:ga703f1f9c8c8211c8697987d6968f8a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b186bd861385826efd67fb1ecc25144"><td class="memItemLeft" align="right" valign="top"><a id="ga2b186bd861385826efd67fb1ecc25144"></a>
constexpr I <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::rotate</b> (I first, I middle, <a class="el" href="structS.html">S</a> last)</td></tr>
<tr class="separator:ga2b186bd861385826efd67fb1ecc25144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac575e217aabac392adc80268a398f162"><td class="memItemLeft" align="right" valign="top"><a id="gac575e217aabac392adc80268a398f162"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac575e217aabac392adc80268a398f162">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gac575e217aabac392adc80268a398f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>rotate_copy</code> <br /></td></tr>
<tr class="separator:gac575e217aabac392adc80268a398f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee4effee4bcac8d0d3ebade645b237df"><td class="memItemLeft" align="right" valign="top"><a id="gaee4effee4bcac8d0d3ebade645b237df"></a>
I AND weakly_incrementable&lt; O &gt; AND constexpr indirectly_copyable&lt; I, O &gt; rotate_copy_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::rotate_copy</b> (I first, I middle, <a class="el" href="structS.html">S</a> last, O out)</td></tr>
<tr class="separator:gaee4effee4bcac8d0d3ebade645b237df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031deefb52490c74bf5fb9fc9352b37c"><td class="memItemLeft" align="right" valign="top"><a id="ga031deefb52490c74bf5fb9fc9352b37c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga031deefb52490c74bf5fb9fc9352b37c">ranges::template</a> (typename Rng, typename O, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires range&lt; Rng &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;</td></tr>
<tr class="memdesc:ga031deefb52490c74bf5fb9fc9352b37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga031deefb52490c74bf5fb9fc9352b37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6439fcff7a3e801bbb0379f4dc6d47"><td class="memItemLeft" align="right" valign="top"><a id="ga8e6439fcff7a3e801bbb0379f4dc6d47"></a>
constexpr O rotate_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::rotate_copy</b> (Rng &amp;&amp;rng, <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; middle, O out)</td></tr>
<tr class="separator:ga8e6439fcff7a3e801bbb0379f4dc6d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4a95b3e253adc8e2dea7c0734555d9d"><td class="memItemLeft" align="right" valign="top"><a id="gae4a95b3e253adc8e2dea7c0734555d9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae4a95b3e253adc8e2dea7c0734555d9d">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename O, typename Gen=detail::default_random_engine &amp;)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gae4a95b3e253adc8e2dea7c0734555d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>sample</code> <br /></td></tr>
<tr class="separator:gae4a95b3e253adc8e2dea7c0734555d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f95fecbe381b354e0edf2eb60fc4ed3"><td class="memItemLeft" align="right" valign="top"><a id="ga7f95fecbe381b354e0edf2eb60fc4ed3"></a>
I AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; I, O &gt; AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::AND</b> (random_access_iterator&lt; O &gt;||<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I &gt;||sized_sentinel_for&lt; <a class="el" href="structS.html">S</a>, I &gt;)) sample_result&lt; I</td></tr>
<tr class="separator:ga7f95fecbe381b354e0edf2eb60fc4ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3385d2756279411d04a1564e52227777"><td class="memItemLeft" align="right" valign="top"><a id="ga3385d2756279411d04a1564e52227777"></a>
I AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; I, O &gt; AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sample</b> (I first, <a class="el" href="structS.html">S</a> last, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="separator:ga3385d2756279411d04a1564e52227777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73994f4085540507d00e51d98ba495ff"><td class="memItemLeft" align="right" valign="top"><a id="ga73994f4085540507d00e51d98ba495ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga73994f4085540507d00e51d98ba495ff">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename ORng, typename Gen=detail::default_random_engine &amp;)(requires input_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:ga73994f4085540507d00e51d98ba495ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga73994f4085540507d00e51d98ba495ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa762a658136622337071cd1ad1122ba3"><td class="memItemLeft" align="right" valign="top"><a id="gaa762a658136622337071cd1ad1122ba3"></a>
I AND weakly_incrementable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt; &gt; AND indirectly_copyable&lt; I, <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt; &gt; AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::AND</b> (forward_range&lt; ORng &gt;||sized_range&lt; ORng &gt;) AND(random_access_iterator&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt;&gt;||<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I &gt;||sized_sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="separator:gaa762a658136622337071cd1ad1122ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade92c2d35887c1b68dfef0581b057514"><td class="memItemLeft" align="right" valign="top"><a id="gade92c2d35887c1b68dfef0581b057514"></a>
I AND weakly_incrementable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt; &gt; AND indirectly_copyable&lt; I, <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt; &gt; AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt; I sample_result&lt; I, borrowed_iterator_t&lt; ORng &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sample</b> (I first, <a class="el" href="structS.html">S</a> last, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="separator:gade92c2d35887c1b68dfef0581b057514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c450d95b52e9ee06f51ce47306cd689"><td class="memItemLeft" align="right" valign="top"><a id="ga2c450d95b52e9ee06f51ce47306cd689"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2c450d95b52e9ee06f51ce47306cd689">ranges::template</a> (typename Rng, typename O, typename Gen=detail::default_random_engine &amp;)(requires input_range&lt; Rng &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;</td></tr>
<tr class="memdesc:ga2c450d95b52e9ee06f51ce47306cd689"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga2c450d95b52e9ee06f51ce47306cd689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf057f5baa502213745ea27a544930a97"><td class="memItemLeft" align="right" valign="top"><a id="gaf057f5baa502213745ea27a544930a97"></a>
O AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::AND</b> (random_access_iterator&lt; O &gt;||forward_range&lt; Rng &gt;||sized_range&lt; Rng &gt;)) sample_result&lt; borrowed_iterator_t&lt; Rng &gt;</td></tr>
<tr class="separator:gaf057f5baa502213745ea27a544930a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6c71035b70d206dc4a307181971e34"><td class="memItemLeft" align="right" valign="top"><a id="ga0f6c71035b70d206dc4a307181971e34"></a>
O AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sample</b> (Rng &amp;&amp;rng, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="separator:ga0f6c71035b70d206dc4a307181971e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5aa8e33d464b1c7d12bed7657607b1f"><td class="memItemLeft" align="right" valign="top"><a id="gab5aa8e33d464b1c7d12bed7657607b1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab5aa8e33d464b1c7d12bed7657607b1f">ranges::template</a> (typename IRng, typename ORng, typename Gen=detail::default_random_engine &amp;)(requires input_range&lt; IRng &gt; AND range&lt; ORng &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; IRng &gt;</td></tr>
<tr class="memdesc:gab5aa8e33d464b1c7d12bed7657607b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab5aa8e33d464b1c7d12bed7657607b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef02897d62bc5beec5a466f41dd4182"><td class="memItemLeft" align="right" valign="top"><a id="ga8ef02897d62bc5beec5a466f41dd4182"></a>
<a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt; AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::AND</b> (random_access_iterator&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt;&gt;||forward_range&lt; IRng &gt;||sized_range&lt; IRng &gt;) AND(forward_range&lt; ORng &gt;||sized_range&lt; ORng &gt;)) sample_result&lt; borrowed_iterator_t&lt; IRng &gt;</td></tr>
<tr class="separator:ga8ef02897d62bc5beec5a466f41dd4182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a8157a1da795fb0ae1bdf416665c4f"><td class="memItemLeft" align="right" valign="top"><a id="gae9a8157a1da795fb0ae1bdf416665c4f"></a>
<a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; ORng &gt; AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt; borrowed_iterator_t&lt; ORng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sample</b> (IRng &amp;&amp;rng, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="separator:gae9a8157a1da795fb0ae1bdf416665c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9a21dc33b3d1272d75ea07ada50c60"><td class="memItemLeft" align="right" valign="top"><a id="ga7b9a21dc33b3d1272d75ea07ada50c60"></a>
I1 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I2 &gt; AND sentinel_for&lt; S2, I2 &gt; AND constexpr indirectly_comparable&lt; I1, I2, <a class="el" href="classC.html">C</a>, P1, P2 &gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::search</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga7b9a21dc33b3d1272d75ea07ada50c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf8e0e1ce3e85f7a4739715d1a08697"><td class="memItemLeft" align="right" valign="top"><a id="gacaf8e0e1ce3e85f7a4739715d1a08697"></a>
constexpr P2 borrowed_subrange_t&lt; Rng1 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::search</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:gacaf8e0e1ce3e85f7a4739715d1a08697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423302e5029a88a153271a731befc5f7"><td class="memItemLeft" align="right" valign="top"><a id="ga423302e5029a88a153271a731befc5f7"></a>
I AND constexpr indirectly_comparable&lt; I, V const *, <a class="el" href="classC.html">C</a>, P &gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::search_n</b> (I first, <a class="el" href="structS.html">S</a> last, iter_difference_t&lt; I &gt; cnt, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga423302e5029a88a153271a731befc5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f71955ab4065f5d8ab4ae7929b17b9"><td class="memItemLeft" align="right" valign="top"><a id="gad7f71955ab4065f5d8ab4ae7929b17b9"></a>
V const constexpr P borrowed_subrange_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::search_n</b> (Rng &amp;&amp;rng, iter_difference_t&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;&gt; cnt, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gad7f71955ab4065f5d8ab4ae7929b17b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1897e3de6c6f02b3b0b4ea28e493eeb8"><td class="memItemLeft" align="right" valign="top"><a id="ga1897e3de6c6f02b3b0b4ea28e493eeb8"></a>
I1 AND input_iterator&lt; I2 &gt; AND sentinel_for&lt; S2, I2 &gt; AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, projected&lt; I1, P1 &gt;, projected&lt; I2, P2 &gt; &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::includes</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga1897e3de6c6f02b3b0b4ea28e493eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0282921372bc8fd9ff3a8d7f0251d382"><td class="memItemLeft" align="right" valign="top"><a id="ga0282921372bc8fd9ff3a8d7f0251d382"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng2 &gt;, P2 &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::includes</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga0282921372bc8fd9ff3a8d7f0251d382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0157928d74566b78b7efd9d2e41829f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0157928d74566b78b7efd9d2e41829f4">ranges::template</a> (typename I1, typename S1, typename I2, typename S2, typename O, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires sentinel_for&lt; S1</td></tr>
<tr class="memdesc:ga0157928d74566b78b7efd9d2e41829f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_union</code>  <a href="group__group-algorithms.html#ga0157928d74566b78b7efd9d2e41829f4">More...</a><br /></td></tr>
<tr class="separator:ga0157928d74566b78b7efd9d2e41829f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee08c8b8902393140557be4ef2b5fc4"><td class="memItemLeft" align="right" valign="top"><a id="ga3ee08c8b8902393140557be4ef2b5fc4"></a>
I1 AND sentinel_for&lt; S2, I2 &gt; AND constexpr mergeable&lt; I1, I2, O, <a class="el" href="classC.html">C</a>, P1, P2 &gt; set_union_result&lt; I1, I2, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_union</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga3ee08c8b8902393140557be4ef2b5fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69f26def74c2ee02cacf24200a715c8"><td class="memItemLeft" align="right" valign="top"><a id="gab69f26def74c2ee02cacf24200a715c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab69f26def74c2ee02cacf24200a715c8">ranges::template</a> (typename Rng1, typename Rng2, typename O, typename <a class="el" href="classC.html">C</a>=<a class="el" href="structranges_1_1less.html">less</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires range&lt; Rng1 &gt; AND range&lt; Rng2 &gt; AND mergeable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;</td></tr>
<tr class="memdesc:gab69f26def74c2ee02cacf24200a715c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab69f26def74c2ee02cacf24200a715c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15dac603f864ba87f0e04b1e81d7f688"><td class="memItemLeft" align="right" valign="top"><a id="ga15dac603f864ba87f0e04b1e81d7f688"></a>
constexpr P2 set_union_result&lt; borrowed_iterator_t&lt; Rng1 &gt;, borrowed_iterator_t&lt; Rng2 &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_union</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga15dac603f864ba87f0e04b1e81d7f688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a03eb792cdc76c0d32f6de0d96f8476"><td class="memItemLeft" align="right" valign="top"><a id="ga1a03eb792cdc76c0d32f6de0d96f8476"></a>
I1 AND sentinel_for&lt; S2, I2 &gt; AND constexpr mergeable&lt; I1, I2, O, <a class="el" href="classC.html">C</a>, P1, P2 &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_intersection</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga1a03eb792cdc76c0d32f6de0d96f8476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2408bc10bf6aed892b731c1a2e58fa5e"><td class="memItemLeft" align="right" valign="top"><a id="ga2408bc10bf6aed892b731c1a2e58fa5e"></a>
constexpr P2 O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_intersection</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga2408bc10bf6aed892b731c1a2e58fa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd054739cff819719dd317ae789332da"><td class="memItemLeft" align="right" valign="top"><a id="gafd054739cff819719dd317ae789332da"></a>
I1 AND sentinel_for&lt; S2, I2 &gt; AND constexpr mergeable&lt; I1, I2, O, <a class="el" href="classC.html">C</a>, P1, P2 &gt; set_difference_result&lt; I1, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_difference</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:gafd054739cff819719dd317ae789332da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04aa749872bf1a625f3dede19f10036d"><td class="memItemLeft" align="right" valign="top"><a id="ga04aa749872bf1a625f3dede19f10036d"></a>
constexpr P2 set_difference_result&lt; borrowed_iterator_t&lt; Rng1 &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_difference</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga04aa749872bf1a625f3dede19f10036d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333fcd9bc48385b429be188294d93a78"><td class="memItemLeft" align="right" valign="top"><a id="ga333fcd9bc48385b429be188294d93a78"></a>
I1 AND sentinel_for&lt; S2, I2 &gt; AND constexpr mergeable&lt; I1, I2, O, <a class="el" href="classC.html">C</a>, P1, P2 &gt; set_symmetric_difference_result&lt; I1, I2, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_symmetric_difference</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga333fcd9bc48385b429be188294d93a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154f0efb2fbc04f402ad475c2cd505e6"><td class="memItemLeft" align="right" valign="top"><a id="ga154f0efb2fbc04f402ad475c2cd505e6"></a>
constexpr P2 set_symmetric_difference_result&lt; borrowed_iterator_t&lt; Rng1 &gt;, borrowed_iterator_t&lt; Rng2 &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::set_symmetric_difference</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="separator:ga154f0efb2fbc04f402ad475c2cd505e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41f3dc137d3af4c44231dd254637e51"><td class="memItemLeft" align="right" valign="top"><a id="gac41f3dc137d3af4c44231dd254637e51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac41f3dc137d3af4c44231dd254637e51">ranges::template</a> (typename I, typename <a class="el" href="structS.html">S</a>, typename Gen=detail::default_random_engine &amp;)(requires random_access_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a></td></tr>
<tr class="memdesc:gac41f3dc137d3af4c44231dd254637e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>shuffle</code> <br /></td></tr>
<tr class="separator:gac41f3dc137d3af4c44231dd254637e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a9c0196dca1ab57bb74ecaa8c700ab"><td class="memItemLeft" align="right" valign="top"><a id="gac4a9c0196dca1ab57bb74ecaa8c700ab"></a>
I AND permutable&lt; I &gt; AND uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt; &gt; AND convertible_to&lt; invoke_result_t&lt; Gen &amp; &gt;, iter_difference_t&lt; I &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::shuffle</b> (I const first, <a class="el" href="structS.html">S</a> const last, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="separator:gac4a9c0196dca1ab57bb74ecaa8c700ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63708b079ea93c0bf870ca4369ec936d"><td class="memItemLeft" align="right" valign="top"><a id="ga63708b079ea93c0bf870ca4369ec936d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga63708b079ea93c0bf870ca4369ec936d">ranges::template</a> (typename Rng, typename Gen=detail::default_random_engine &amp;)(requires random_access_range&lt; Rng &gt; AND permutable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;&gt; AND uniform_random_bit_generator&lt; std</td></tr>
<tr class="memdesc:ga63708b079ea93c0bf870ca4369ec936d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga63708b079ea93c0bf870ca4369ec936d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab766b77e869ed476f045655eb10c077d"><td class="memItemLeft" align="right" valign="top"><a id="gab766b77e869ed476f045655eb10c077d"></a>
P AND random_access_iterator&lt; I &gt; AND constexpr sentinel_for&lt; <a class="el" href="structS.html">S</a>, I &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sort</b> (I first, <a class="el" href="structS.html">S</a> end_, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gab766b77e869ed476f045655eb10c077d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e92c28516a6284bd835673b9217718d"><td class="memItemLeft" align="right" valign="top"><a id="ga6e92c28516a6284bd835673b9217718d"></a>
P AND constexpr random_access_range&lt; Rng &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::sort</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga6e92c28516a6284bd835673b9217718d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78fe8e8e0a127e5a5288b75e0a972ca3"><td class="memItemLeft" align="right" valign="top"><a id="ga78fe8e8e0a127e5a5288b75e0a972ca3"></a>
I AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; AND permutable&lt; I &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::stable_partition</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga78fe8e8e0a127e5a5288b75e0a972ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d0cdbf72053fd3a1e39a8f176efaeab"><td class="memItemLeft" align="right" valign="top"><a id="ga5d0cdbf72053fd3a1e39a8f176efaeab"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND permutable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt; &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::stable_partition</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga5d0cdbf72053fd3a1e39a8f176efaeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb471352debb4f6230ccf9b620034ab"><td class="memItemLeft" align="right" valign="top"><a id="ga5eb471352debb4f6230ccf9b620034ab"></a>
P AND random_access_iterator&lt; I &gt; AND sentinel_for&lt; <a class="el" href="structS.html">S</a>, I &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::stable_sort</b> (I first, <a class="el" href="structS.html">S</a> end_, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga5eb471352debb4f6230ccf9b620034ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeef8e53140789babee0a01b0ee1384d"><td class="memItemLeft" align="right" valign="top"><a id="gabeef8e53140789babee0a01b0ee1384d"></a>
P AND random_access_range&lt; Rng &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::stable_sort</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gabeef8e53140789babee0a01b0ee1384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8984ae8cb386ddb261390dc3fd1812"><td class="memItemLeft" align="right" valign="top"><a id="ga0b8984ae8cb386ddb261390dc3fd1812"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0b8984ae8cb386ddb261390dc3fd1812">ranges::template</a> (typename I1, typename S1, typename I2, typename S2, typename Comp=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename Proj1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename Proj2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I1 &gt; AND sentinel_for&lt; S1</td></tr>
<tr class="memdesc:ga0b8984ae8cb386ddb261390dc3fd1812"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>starts_with</code> <br /></td></tr>
<tr class="separator:ga0b8984ae8cb386ddb261390dc3fd1812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f099467752d68c28ec4caa42cb41e1a"><td class="memItemLeft" align="right" valign="top"><a id="ga1f099467752d68c28ec4caa42cb41e1a"></a>
I1 AND input_iterator&lt; I2 &gt; AND sentinel_for&lt; S2, I2 &gt; AND constexpr indirectly_comparable&lt; I1, I2, Comp, Proj1, Proj2 &gt; bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::starts_with</b> (I1 first1, S1 last1, I2 first2, S2 last2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="separator:ga1f099467752d68c28ec4caa42cb41e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96846891e01e84b2fe2e9a2351e30705"><td class="memItemLeft" align="right" valign="top"><a id="ga96846891e01e84b2fe2e9a2351e30705"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga96846891e01e84b2fe2e9a2351e30705">ranges::template</a> (typename R1, typename R2, typename Comp=<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, typename Proj1=<a class="el" href="structranges_1_1identity.html">identity</a>, typename Proj2=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; R1 &gt; AND input_range&lt; R2 &gt; AND indirectly_comparable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; R1 &gt;</td></tr>
<tr class="memdesc:ga96846891e01e84b2fe2e9a2351e30705"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga96846891e01e84b2fe2e9a2351e30705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c2d42f96d4246ce47b3134d0b8b6bd"><td class="memItemLeft" align="right" valign="top"><a id="gad2c2d42f96d4246ce47b3134d0b8b6bd"></a>
constexpr Proj2 bool RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::starts_with</b> (R1 &amp;&amp;r1, R2 &amp;&amp;r2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="separator:gad2c2d42f96d4246ce47b3134d0b8b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1307a2f95888ee15e8b9f992d1ce9f8"><td class="memItemLeft" align="right" valign="top"><a id="gaa1307a2f95888ee15e8b9f992d1ce9f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa1307a2f95888ee15e8b9f992d1ce9f8">ranges::template</a> (typename I1, typename S1, typename I2)(requires input_iterator&lt; I1 &gt; AND sentinel_for&lt; S1</td></tr>
<tr class="memdesc:gaa1307a2f95888ee15e8b9f992d1ce9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>swap_ranges</code> <br /></td></tr>
<tr class="separator:gaa1307a2f95888ee15e8b9f992d1ce9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46782c91ee3a0a5358b0a40d5c182ab"><td class="memItemLeft" align="right" valign="top"><a id="gae46782c91ee3a0a5358b0a40d5c182ab"></a>
I1 AND input_iterator&lt; I2 &gt; AND constexpr indirectly_swappable&lt; I1, I2 &gt; swap_ranges_result&lt; I1, I2 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::swap_ranges</b> (I1 begin1, S1 end1, I2 begin2)</td></tr>
<tr class="separator:gae46782c91ee3a0a5358b0a40d5c182ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9caea5747a456a21f53377b86c2f9829"><td class="memItemLeft" align="right" valign="top"><a id="ga9caea5747a456a21f53377b86c2f9829"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9caea5747a456a21f53377b86c2f9829">ranges::template</a> (typename I1, typename S1, typename I2, typename S2)(requires input_iterator&lt; I1 &gt; AND sentinel_for&lt; S1</td></tr>
<tr class="memdesc:ga9caea5747a456a21f53377b86c2f9829"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga9caea5747a456a21f53377b86c2f9829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a43525f3b75421f98b67b14d1ad8965"><td class="memItemLeft" align="right" valign="top"><a id="ga0a43525f3b75421f98b67b14d1ad8965"></a>
I1 AND input_iterator&lt; I2 &gt; AND sentinel_for&lt; S2, I2 &gt; AND constexpr indirectly_swappable&lt; I1, I2 &gt; swap_ranges_result&lt; I1, I2 &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::swap_ranges</b> (I1 begin1, S1 end1, I2 begin2, S2 end2)</td></tr>
<tr class="separator:ga0a43525f3b75421f98b67b14d1ad8965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5999bf55e28e33d7b379f4bb29081ea"><td class="memItemLeft" align="right" valign="top"><a id="gae5999bf55e28e33d7b379f4bb29081ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::template</b> (typename Rng1, typename I2_)(requires input_range&lt; Rng1 &gt; AND input_iterator&lt; uncvref_t&lt; I2_ &gt;&gt; AND indirectly_swappable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;</td></tr>
<tr class="separator:gae5999bf55e28e33d7b379f4bb29081ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5051ec4d4f12b160e51f827b57ccd89d"><td class="memItemLeft" align="right" valign="top"><a id="ga5051ec4d4f12b160e51f827b57ccd89d"></a>
constexpr uncvref_t&lt; I2_ &gt; swap_ranges_result&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;, uncvref_t&lt; I2_ &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::swap_ranges</b> (Rng1 &amp;&amp;rng1, I2_ &amp;&amp;begin2)</td></tr>
<tr class="separator:ga5051ec4d4f12b160e51f827b57ccd89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161d092eb72f7943ad8abb068fd6ca02"><td class="memItemLeft" align="right" valign="top"><a id="ga161d092eb72f7943ad8abb068fd6ca02"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::template</b> (typename Rng1, typename Rng2)(requires input_range&lt; Rng1 &gt; AND input_range&lt; Rng2 &gt; AND indirectly_swappable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;</td></tr>
<tr class="separator:ga161d092eb72f7943ad8abb068fd6ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444b4c12855e1931ac31bc1cb006ece1"><td class="memItemLeft" align="right" valign="top"><a id="ga444b4c12855e1931ac31bc1cb006ece1"></a>
constexpr <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng2 &gt; swap_ranges_result&lt; borrowed_iterator_t&lt; Rng1 &gt;, borrowed_iterator_t&lt; Rng2 &gt; &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::swap_ranges</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2)</td></tr>
<tr class="separator:ga444b4c12855e1931ac31bc1cb006ece1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590c6a6eed352ff2d62e95858714682c"><td class="memItemLeft" align="right" valign="top"><a id="ga590c6a6eed352ff2d62e95858714682c"></a>
I AND weakly_incrementable&lt; O &gt; AND copy_constructible&lt; F &gt; AND constexpr indirectly_writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; I, P &gt; &gt; &gt; unary_transform_result&lt; I, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::transform</b> (I first, <a class="el" href="structS.html">S</a> last, O out, F fun, P proj=P{})</td></tr>
<tr class="separator:ga590c6a6eed352ff2d62e95858714682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7da996272f4b2cacede2804c1e5a305"><td class="memItemLeft" align="right" valign="top"><a id="gaf7da996272f4b2cacede2804c1e5a305"></a>
constexpr indirect_result_t&lt; F &amp;, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; &gt; unary_transform_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::transform</b> (Rng &amp;&amp;rng, O out, F fun, P proj=P{})</td></tr>
<tr class="separator:gaf7da996272f4b2cacede2804c1e5a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db9515b2b6ff60d6afeb89e7ffdba2e"><td class="memItemLeft" align="right" valign="top"><a id="ga9db9515b2b6ff60d6afeb89e7ffdba2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9db9515b2b6ff60d6afeb89e7ffdba2e">ranges::template</a> (typename I0, typename S0, typename I1, typename S1, typename O, typename F, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I0 &gt; AND sentinel_for&lt; S0</td></tr>
<tr class="memdesc:ga9db9515b2b6ff60d6afeb89e7ffdba2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga9db9515b2b6ff60d6afeb89e7ffdba2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7b38950cea956b415d96d52679b692"><td class="memItemLeft" align="right" valign="top"><a id="ga9d7b38950cea956b415d96d52679b692"></a>
I0 AND input_iterator&lt; I1 &gt; AND sentinel_for&lt; S1, I1 &gt; AND weakly_incrementable&lt; O &gt; AND copy_constructible&lt; F &gt; AND constexpr indirectly_writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt; &gt; &gt; binary_transform_result&lt; I0, I1, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::transform</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga9d7b38950cea956b415d96d52679b692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43b4b640a32aa9d54d4b0c1d6e2da05"><td class="memItemLeft" align="right" valign="top"><a id="gab43b4b640a32aa9d54d4b0c1d6e2da05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab43b4b640a32aa9d54d4b0c1d6e2da05">ranges::template</a> (typename Rng0, typename Rng1, typename O, typename F, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng0 &gt; AND input_range&lt; Rng1 &gt; AND weakly_incrementable&lt; O &gt; AND copy_constructible&lt; F &gt; AND indirectly_writable&lt; O</td></tr>
<tr class="memdesc:gab43b4b640a32aa9d54d4b0c1d6e2da05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab43b4b640a32aa9d54d4b0c1d6e2da05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401c9e252f8b183e0e7c52295b2c1e7b"><td class="memItemLeft" align="right" valign="top"><a id="ga401c9e252f8b183e0e7c52295b2c1e7b"></a>
constexpr indirect_result_t&lt; F &amp;, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng0 &gt;, P0 &gt;, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng1 &gt;, P1 &gt; &gt; binary_transform_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, borrowed_iterator_t&lt; Rng1 &gt;, O &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::transform</b> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga401c9e252f8b183e0e7c52295b2c1e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3348810f044fd3e7a84e7814f26cf30d"><td class="memItemLeft" align="right" valign="top"><a id="ga3348810f044fd3e7a84e7814f26cf30d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga3348810f044fd3e7a84e7814f26cf30d">ranges::template</a> (typename I0, typename S0, typename I1, typename O, typename F, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_iterator&lt; I0 &gt; AND sentinel_for&lt; S0</td></tr>
<tr class="memdesc:ga3348810f044fd3e7a84e7814f26cf30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3348810f044fd3e7a84e7814f26cf30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2be9782a5a5df0c6248ebc117d6cfb"><td class="memItemLeft" align="right" valign="top"><a id="ga6c2be9782a5a5df0c6248ebc117d6cfb"></a>
I0 AND input_iterator&lt; I1 &gt; AND weakly_incrementable&lt; O &gt; AND copy_constructible&lt; F &gt; AND indirectly_writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::RANGES_DEPRECATED</b> (&quot;Use the <a class="el" href="structranges_1_1variant.html">variant</a> of ranges::transform that takes an upper bound &quot; &quot;for both input ranges&quot;) binary_transform_result&lt; I0</td></tr>
<tr class="separator:ga6c2be9782a5a5df0c6248ebc117d6cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51084f65066bd36e260dff81d5db8943"><td class="memItemLeft" align="right" valign="top"><a id="ga51084f65066bd36e260dff81d5db8943"></a>
I0 AND input_iterator&lt; I1 &gt; AND weakly_incrementable&lt; O &gt; AND copy_constructible&lt; F &gt; AND indirectly_writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt; &gt; &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::transform</b> (I0 begin0, S0 end0, I1 begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:ga51084f65066bd36e260dff81d5db8943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13641c37b946dd04f6932899b4da0581"><td class="memItemLeft" align="right" valign="top"><a id="ga13641c37b946dd04f6932899b4da0581"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga13641c37b946dd04f6932899b4da0581">ranges::template</a> (typename Rng0, typename I1Ref, typename O, typename F, typename P0=<a class="el" href="structranges_1_1identity.html">identity</a>, typename P1=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires input_range&lt; Rng0 &gt; AND input_iterator&lt; uncvref_t&lt; I1Ref &gt;&gt; AND weakly_incrementable&lt; O &gt; AND copy_constructible&lt; F &gt; AND indirectly_writable&lt; O</td></tr>
<tr class="memdesc:ga13641c37b946dd04f6932899b4da0581"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga13641c37b946dd04f6932899b4da0581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac61385647fe3f0f48c46c3da33a65796"><td class="memItemLeft" align="right" valign="top"><a id="gac61385647fe3f0f48c46c3da33a65796"></a>
indirect_result_t&lt; F &amp;, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng0 &gt;, P0 &gt;, projected&lt; uncvref_t&lt; I1Ref &gt;, P1 &gt; &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::transform</b> (Rng0 &amp;&amp;rng0, I1Ref &amp;&amp;begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="separator:gac61385647fe3f0f48c46c3da33a65796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e712171e1efe861ffcd9036a57bb50"><td class="memItemLeft" align="right" valign="top"><a id="ga57e712171e1efe861ffcd9036a57bb50"></a>
P AND constexpr sentinel_for&lt; <a class="el" href="structS.html">S</a>, I &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::unique</b> (I first, <a class="el" href="structS.html">S</a> last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga57e712171e1efe861ffcd9036a57bb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb807da69a68741d2ad7cee399970592"><td class="memItemLeft" align="right" valign="top"><a id="gaeb807da69a68741d2ad7cee399970592"></a>
P AND constexpr range&lt; Rng &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::unique</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaeb807da69a68741d2ad7cee399970592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dca2f74df337706a5822a48dbfb6de1"><td class="memItemLeft" align="right" valign="top"><a id="ga5dca2f74df337706a5822a48dbfb6de1"></a>
I AND indirect_relation&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; I, O &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::AND</b> (<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I &gt;||<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; O &gt;||indirectly_copyable_storable&lt; I, O &gt;)) const expr unique_copy_result&lt; I</td></tr>
<tr class="separator:ga5dca2f74df337706a5822a48dbfb6de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8858d866b2fd0bc958d0daa1b9775ba"><td class="memItemLeft" align="right" valign="top"><a id="gad8858d866b2fd0bc958d0daa1b9775ba"></a>
I AND indirect_relation&lt; <a class="el" href="classC.html">C</a>, projected&lt; I, P &gt; &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; I, O &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::unique_copy</b> (I first, <a class="el" href="structS.html">S</a> last, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gad8858d866b2fd0bc958d0daa1b9775ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0018dc1423d9d4d2f5a7d2e43e90edc"><td class="memItemLeft" align="right" valign="top"><a id="gad0018dc1423d9d4d2f5a7d2e43e90edc"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::AND</b> (<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;&gt;||<a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; O &gt;||indirectly_copyable_storable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt;)) const expr unique_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;</td></tr>
<tr class="separator:gad0018dc1423d9d4d2f5a7d2e43e90edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74dd924cc2472f227359fd638420c74"><td class="memItemLeft" align="right" valign="top"><a id="gaf74dd924cc2472f227359fd638420c74"></a>
projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; AND weakly_incrementable&lt; O &gt; AND indirectly_copyable&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, O &gt; O RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::unique_copy</b> (Rng &amp;&amp;rng, O out, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:gaf74dd924cc2472f227359fd638420c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6720966a823b7ae805fb7e09697a270"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad6720966a823b7ae805fb7e09697a270">ranges::template</a> (typename I, typename <a class="el" href="classC.html">C</a>, typename P=<a class="el" href="structranges_1_1identity.html">identity</a>)(requires bidirectional_iterator&lt; I &gt; AND permutable&lt; I &gt; AND indirect_unary_predicate&lt; <a class="el" href="classC.html">C</a></td></tr>
<tr class="memdesc:gad6720966a823b7ae805fb7e09697a270"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>unstable_remove_if</code>  <a href="group__group-algorithms.html#gad6720966a823b7ae805fb7e09697a270">More...</a><br /></td></tr>
<tr class="separator:gad6720966a823b7ae805fb7e09697a270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6427f179b70695184dc7ee3fc60343c"><td class="memItemLeft" align="right" valign="top"><a id="gae6427f179b70695184dc7ee3fc60343c"></a>
constexpr projected&lt; I, P &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::unstable_remove_if</b> (I first, I last, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj={})</td></tr>
<tr class="separator:gae6427f179b70695184dc7ee3fc60343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842b0d6e0b307380d8f83d3fa6f8657c"><td class="memItemLeft" align="right" valign="top"><a id="ga842b0d6e0b307380d8f83d3fa6f8657c"></a>
constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::unstable_remove_if</b> (Rng &amp;&amp;rng, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>, P proj=P{})</td></tr>
<tr class="separator:ga842b0d6e0b307380d8f83d3fa6f8657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593760079a7ac13188371c71148b0cf3"><td class="memItemLeft" align="right" valign="top"><a id="ga593760079a7ac13188371c71148b0cf3"></a>
I AND constexpr indirect_strict_weak_order&lt; <a class="el" href="classC.html">C</a>, V const *, projected&lt; I, P &gt; &gt; I RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::upper_bound</b> (I first, <a class="el" href="structS.html">S</a> last, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga593760079a7ac13188371c71148b0cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249cb8ffec446a9f5cf4ea6134d39476"><td class="memItemLeft" align="right" valign="top"><a id="ga249cb8ffec446a9f5cf4ea6134d39476"></a>
V const constexpr projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng &gt;, P &gt; borrowed_iterator_t&lt; Rng &gt; RANGES_FUNC()&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::upper_bound</b> (Rng &amp;&amp;rng, V const &amp;val, <a class="el" href="classC.html">C</a> <a class="el" href="structpred.html">pred</a>=<a class="el" href="classC.html">C</a>{}, P proj=P{})</td></tr>
<tr class="separator:ga249cb8ffec446a9f5cf4ea6134d39476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3371c7ddad084ac4202104fbd12924da"><td class="memItemLeft" align="right" valign="top"><a id="ga3371c7ddad084ac4202104fbd12924da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::projected&lt; iterator_t&lt; Rng &gt;, P &gt;</b></td></tr>
<tr class="separator:ga3371c7ddad084ac4202104fbd12924da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f63633ecd61d66fbb72e30f6fa8f777"><td class="memItemLeft" align="right" valign="top"><a id="ga8f63633ecd61d66fbb72e30f6fa8f777"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::iterator_t&lt; Rng2 &gt;</b></td></tr>
<tr class="separator:ga8f63633ecd61d66fbb72e30f6fa8f777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1d12b279b12b5be141f2b2d1c95cbd"><td class="memItemLeft" align="right" valign="top"><a id="gaea1d12b279b12b5be141f2b2d1c95cbd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::Pred</b></td></tr>
<tr class="separator:gaea1d12b279b12b5be141f2b2d1c95cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee8455683d9428b8ee406d618586dc6"><td class="memItemLeft" align="right" valign="top"><a id="gabee8455683d9428b8ee406d618586dc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::Proj1</b></td></tr>
<tr class="separator:gabee8455683d9428b8ee406d618586dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b49279ec920a903f934b5769e9a49d"><td class="memItemLeft" align="right" valign="top"><a id="gaa0b49279ec920a903f934b5769e9a49d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::I1</b></td></tr>
<tr class="separator:gaa0b49279ec920a903f934b5769e9a49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa157fefa98319602566439f591a6f150"><td class="memItemLeft" align="right" valign="top"><a id="gaa157fefa98319602566439f591a6f150"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::C</b></td></tr>
<tr class="separator:gaa157fefa98319602566439f591a6f150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471f3520eca7f6aa49edf8100defc5b6"><td class="memItemLeft" align="right" valign="top"><a id="ga471f3520eca7f6aa49edf8100defc5b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::P0</b></td></tr>
<tr class="separator:ga471f3520eca7f6aa49edf8100defc5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac693c49cba8519603114f54224090b4f"><td class="memItemLeft" align="right" valign="top"><a id="gac693c49cba8519603114f54224090b4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::iterator_t&lt; Rng1 &gt;</b></td></tr>
<tr class="separator:gac693c49cba8519603114f54224090b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f02412315dcaedf54cae84aabf1ad2d"><td class="memItemLeft" align="right" valign="top"><a id="ga9f02412315dcaedf54cae84aabf1ad2d"></a>
I0 AND input_iterator&lt; I1 &gt; AND indirectly_comparable&lt; I0, I1, <a class="el" href="classC.html">C</a>, P0, P1 &gt; S0&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::end0</b></td></tr>
<tr class="separator:ga9f02412315dcaedf54cae84aabf1ad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacec5b7aaea5fcd9b6eb30f2cacdbbfd"><td class="memItemLeft" align="right" valign="top"><a id="gaacec5b7aaea5fcd9b6eb30f2cacdbbfd"></a>
I0 AND input_iterator&lt; I1 &gt; AND indirectly_comparable&lt; I0, I1, <a class="el" href="classC.html">C</a>, P0, P1 &gt; S0 I1&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::begin1</b></td></tr>
<tr class="separator:gaacec5b7aaea5fcd9b6eb30f2cacdbbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c716320d945568716a57c6aa52768a8"><td class="memItemLeft" align="right" valign="top"><a id="ga6c716320d945568716a57c6aa52768a8"></a>
I0 AND input_iterator&lt; I1 &gt; AND indirectly_comparable&lt; I0, I1, <a class="el" href="classC.html">C</a>, P0, P1 &gt; S0 I1 <a class="el" href="classC.html">C</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::pred</b> = <a class="el" href="classC.html">C</a>{}</td></tr>
<tr class="separator:ga6c716320d945568716a57c6aa52768a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad376fd6ceb8288b3bf92c2cb3e4e1190"><td class="memItemLeft" align="right" valign="top"><a id="gad376fd6ceb8288b3bf92c2cb3e4e1190"></a>
I0 AND input_iterator&lt; I1 &gt; AND indirectly_comparable&lt; I0, I1, <a class="el" href="classC.html">C</a>, P0, P1 &gt; S0 I1 <a class="el" href="classC.html">C</a> P0&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::proj0</b> = P0{}</td></tr>
<tr class="separator:gad376fd6ceb8288b3bf92c2cb3e4e1190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd558b8a5a134710ab6efc414acd7cf8"><td class="memItemLeft" align="right" valign="top"><a id="gacd558b8a5a134710ab6efc414acd7cf8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::projected&lt; iterator_t&lt; Rng1 &gt;, P &gt;</b></td></tr>
<tr class="separator:gacd558b8a5a134710ab6efc414acd7cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ba880095b553153dc566b011d2da6c"><td class="memItemLeft" align="right" valign="top"><a id="gac4ba880095b553153dc566b011d2da6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::projected&lt; iterator_t&lt; Rng0 &gt;, P0 &gt;</b></td></tr>
<tr class="separator:gac4ba880095b553153dc566b011d2da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5646e2b3065f2893c0ae09a95f8aaf27"><td class="memItemLeft" align="right" valign="top"><a id="ga5646e2b3065f2893c0ae09a95f8aaf27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::T</b></td></tr>
<tr class="separator:ga5646e2b3065f2893c0ae09a95f8aaf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19d92f84098a0c2b0cc2d63b9033b88"><td class="memItemLeft" align="right" valign="top"><a id="gae19d92f84098a0c2b0cc2d63b9033b88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::range_value_t&lt; R &gt;</b></td></tr>
<tr class="separator:gae19d92f84098a0c2b0cc2d63b9033b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f35f6d2f344dc54286c7a4e73ebb4a"><td class="memItemLeft" align="right" valign="top"><a id="gab5f35f6d2f344dc54286c7a4e73ebb4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::O</b></td></tr>
<tr class="separator:gab5f35f6d2f344dc54286c7a4e73ebb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44874ca9c21492b2244a7d40eb940d30"><td class="memItemLeft" align="right" valign="top"><a id="ga44874ca9c21492b2244a7d40eb940d30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::projected&lt; iterator_t&lt; Rng1 &gt;, P1 &gt;</b></td></tr>
<tr class="separator:ga44874ca9c21492b2244a7d40eb940d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2d9323de75f8e07031f47de5e4e17a"><td class="memItemLeft" align="right" valign="top"><a id="gaff2d9323de75f8e07031f47de5e4e17a"></a>
I1 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I2 &gt; AND indirectly_comparable&lt; I1, I2, <a class="el" href="classC.html">C</a>, P1, P2 &gt; S1&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::end1</b></td></tr>
<tr class="separator:gaff2d9323de75f8e07031f47de5e4e17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0041b4e13c71a8a34a4bc0a8ebd76f8e"><td class="memItemLeft" align="right" valign="top"><a id="ga0041b4e13c71a8a34a4bc0a8ebd76f8e"></a>
I1 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I2 &gt; AND indirectly_comparable&lt; I1, I2, <a class="el" href="classC.html">C</a>, P1, P2 &gt; S1 I2&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::begin2</b></td></tr>
<tr class="separator:ga0041b4e13c71a8a34a4bc0a8ebd76f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7588f7efd64ee4f150f041391bf6b2"><td class="memItemLeft" align="right" valign="top"><a id="gacd7588f7efd64ee4f150f041391bf6b2"></a>
I1 AND <a class="el" href="structforward__iterator.html">forward_iterator</a>&lt; I2 &gt; AND indirectly_comparable&lt; I1, I2, <a class="el" href="classC.html">C</a>, P1, P2 &gt; S1 I2 <a class="el" href="classC.html">C</a> P1&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::proj1</b> = P1{}</td></tr>
<tr class="separator:gacd7588f7efd64ee4f150f041391bf6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7573663dfa3d476118f64ab918b029c"><td class="memItemLeft" align="right" valign="top">I&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::middle</b></td></tr>
<tr class="separator:gae7573663dfa3d476118f64ab918b029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f9a3751e1c4b86cc0cdccf26ba08c15"><td class="memItemLeft" align="right" valign="top"><a id="ga5f9a3751e1c4b86cc0cdccf26ba08c15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::P1</b></td></tr>
<tr class="separator:ga5f9a3751e1c4b86cc0cdccf26ba08c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94e3b50f6dd274b0d5d9ed939e569bba"><td class="memItemLeft" align="right" valign="top"><a id="ga94e3b50f6dd274b0d5d9ed939e569bba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::iterator_t&lt; R2 &gt;</b></td></tr>
<tr class="separator:ga94e3b50f6dd274b0d5d9ed939e569bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad688c44da272648763c6e91bd296437a"><td class="memItemLeft" align="right" valign="top"><a id="gad688c44da272648763c6e91bd296437a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::Comp</b></td></tr>
<tr class="separator:gad688c44da272648763c6e91bd296437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704c8560a4406e6245a58e7fd46f5c10"><td class="memItemLeft" align="right" valign="top"><a id="ga704c8560a4406e6245a58e7fd46f5c10"></a>
indirect_result_t&lt; F &amp;, projected&lt; <a class="el" href="group__group-range.html#ga08407b48d5995aa39efd48516353a21f">iterator_t</a>&lt; Rng0 &gt;, P0 &gt;, projected&lt; uncvref_t&lt; I1Ref &gt;, P1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ranges::uncvref_t&lt; I1Ref &gt;</b></td></tr>
<tr class="separator:ga704c8560a4406e6245a58e7fd46f5c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Iterator- and range-based algorithms, like the standard algorithms. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad6720966a823b7ae805fb7e09697a270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6720966a823b7ae805fb7e09697a270">&#9670;&nbsp;</a></span>template() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>unstable_remove_if</code> </p>
<p>unstable_remove have O(1) complexity for each element remove, unlike remove O(n) [for worst case]. Each erased element overwritten (moved in) with last one. unstable_remove_if does not preserve relative element order. </p>

</div>
</div>
<a id="ga22168919ab36c29ff99b10469878874b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22168919ab36c29ff99b10469878874b">&#9670;&nbsp;</a></span>template() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>reverse</code> </p>
<p>function template <code>rotate</code> </p>

</div>
</div>
<a id="ga10408f1ef84603f755275f0af913b95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10408f1ef84603f755275f0af913b95b">&#9670;&nbsp;</a></span>template() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1equal__to.html">equal_to</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>adjacent_find</code> </p>
<p>template function <code>unique</code> </p>
<p>function template <code>stable_sort</code> </p>
<p>function template <code>stable_partition</code> </p>
<p>function template <code>sort</code> </p>
<p>function template <code>remove_if</code> </p>
<p>function template <code>partition_point</code> </p>
<p>function template <code>partition</code> </p>
<p>function template <code>partial_sort</code> </p>
<p>function template <code>nth_element</code> </p>
<p>function template <code>minmax_element</code> </p>
<p>function template <code>min_element</code> </p>
<p>function template <code>max_element</code> </p>
<p>function template <code>is_partitioned</code> </p>
<p>function template <code>inplace_merge</code> </p>
<p>function template <code>make_heap</code> </p>
<p>function template <code>pop_heap</code> </p>
<p>function template <code>push_heap</code> </p>
<p>function template <code>is_heap</code> </p>
<p>function template <code>is_heap_until</code> </p>
<p>range-based version of the <code>adjacent_find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code><a class="el" href="classC.html">C</a></code> is a model of the <code>BinaryPredicate</code> concept</dd></dl>
<p>range-based version of the <code>unique</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code><a class="el" href="structforward__iterator.html">forward_iterator</a></code> concept </dd>
<dd>
<code><a class="el" href="structS.html">S</a></code> is a model of the <code>sentinel_for</code> concept </dd>
<dd>
<code><a class="el" href="classC.html">C</a></code> is a model of the <code>relation</code> concept </dd></dl>

</div>
</div>
<a id="gab94ef31027b6722de9693dfc418b5461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab94ef31027b6722de9693dfc418b5461">&#9670;&nbsp;</a></span>template() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename F&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>all_of</code> </p>
<p>function template <code>none_of</code> </p>
<p>function template <code>for_each</code> </p>
<p>template function <code>find_if_not</code> </p>
<p>template function <code>find</code> </p>
<p>function template <code>any_of</code> </p>
<p>range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code><a class="el" href="structS.html">S</a></code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;<a class="el" href="structX.html">X</a>&gt;</code>, where <code><a class="el" href="structX.html">X</a></code> is the result type of <code>invocable&lt;P, V&gt;</code></dd></dl>
<p>range-based version of the <code>find_if_not</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code><a class="el" href="structS.html">S</a></code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;<a class="el" href="structX.html">X</a>&gt;</code>, where <code><a class="el" href="structX.html">X</a></code> is the result type of <code>invocable&lt;P, V&gt;</code> </dd></dl>

</div>
</div>
<a id="ga23f32de3ff3d15e5852b3226d5dd7515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f32de3ff3d15e5852b3226d5dd7515">&#9670;&nbsp;</a></span>template() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename O&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>copy</code> </p>
<p>function template <code>reverse_copy</code> </p>
<p>function template <code>move_backward</code> </p>
<p>function template <code>move</code> </p>
<p>function template <code>copy_backward</code> </p>

</div>
</div>
<a id="gadd80fd05cd628279b02c31818cf16ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd80fd05cd628279b02c31818cf16ec5">&#9670;&nbsp;</a></span>template() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename O&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1equal__to.html">equal_to</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>remove_copy_if</code> </p>
<p>template function unique_copy</p>
<p>range-based version of the <code>unique_copy</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>input_range</code> concept </dd>
<dd>
<code>O</code> is a model of the <code>weakly_incrementable</code> concept </dd>
<dd>
<code><a class="el" href="classC.html">C</a></code> is a model of the <code>relation</code> concept </dd></dl>

</div>
</div>
<a id="ga48636515458ae0167941939918250650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48636515458ae0167941939918250650">&#9670;&nbsp;</a></span>template() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename O&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename F&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>copy_if</code> </p>
<p>function template <code>transform</code> </p>

</div>
</div>
<a id="ga1f6a91d825b0ee47589afd4b3e7c0883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f6a91d825b0ee47589afd4b3e7c0883">&#9670;&nbsp;</a></span>template() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Pred&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Proj&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function <code>adjacent_remove_if</code> </p>
<p>range-based version of the <code>adjacent_remove_if</code> algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept. </dd>
<dd>
<code>Pred</code> is a model of the <code>BinaryPredicate</code> concept. </dd></dl>

</div>
</div>
<a id="gac65287ec19b97d90dc9eabcff185cea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac65287ec19b97d90dc9eabcff185cea5">&#9670;&nbsp;</a></span>template() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename R&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1less.html">less</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>count_if</code> </p>
<p>template function <code>is_sorted_until</code> </p>
<p>template function <code>is_sorted</code> </p>
<p>range-based version of the <code>is_sorted</code> std algorithm</p>
<p>Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code><a class="el" href="structforward__iterator.html">forward_iterator</a></code> concept </dd>
<dd>
<code><a class="el" href="structS.html">S</a></code> and <code>I</code> model the <code>sentinel_for&lt;<a class="el" href="structS.html">S</a>, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept</dd></dl>
<p>range-based version of the <code>is_sorted_until</code> std algorithm</p>
<p>Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code><a class="el" href="structforward__iterator.html">forward_iterator</a></code> concept </dd>
<dd>
<code><a class="el" href="structS.html">S</a></code> and <code>I</code> model the <code>sentinel_for&lt;<a class="el" href="structS.html">S</a>, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept </dd></dl>

</div>
</div>
<a id="ga89a4199c26c72a128231b2d0ae2cde77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a4199c26c72a128231b2d0ae2cde77">&#9670;&nbsp;</a></span>template() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>contains</code> </p>
<p>function template <code>remove</code> </p>

</div>
</div>
<a id="ga92d5f20d5450ba794e98372dc88d3dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d5f20d5450ba794e98372dc88d3dbf">&#9670;&nbsp;</a></span>template() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename V&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1less.html">less</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>binary_search</code> </p>
<p>function template <code>upper_bound</code> </p>
<p>function template <code>search_n</code> </p>
<p>function template <code>lower_bound</code> </p>
<p>function template <code>equal_range</code> </p>
<p>range-based version of the <code>binary_search</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd></dl>

</div>
</div>
<a id="ga50641d7749eee48ff05de71d75d089ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50641d7749eee48ff05de71d75d089ac">&#9670;&nbsp;</a></span>template() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structS.html">S</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename V&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>count</code> </p>
<p>template function <code>find</code> </p>
<p>range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code><a class="el" href="structS.html">S</a></code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;iter_common_reference_t&lt;I&gt;&gt;</code> concept </dd>
<dd>
The ResultType of <code>P</code> is equality_comparable with V </dd></dl>

</div>
</div>
<a id="ga7478ecfb8054880ee4ccb9181fba8eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7478ecfb8054880ee4ccb9181fba8eba">&#9670;&nbsp;</a></span>template() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename S1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename I2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1equal__to.html">equal_to</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P1&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P2&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>mismatch</code> </p>
<p>function template <code>is_permutation</code> </p>

</div>
</div>
<a id="ga88a3ebd3a1fa3847fe6e195ae39a95c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a3ebd3a1fa3847fe6e195ae39a95c2">&#9670;&nbsp;</a></span>template() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename S1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename I2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename S2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1equal__to.html">equal_to</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P1&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P2&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>function template <code>includes</code> </p>
<p>function template <code>search</code> </p>

</div>
</div>
<a id="ga0157928d74566b78b7efd9d2e41829f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0157928d74566b78b7efd9d2e41829f4">&#9670;&nbsp;</a></span>template() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename S1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename I2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename S2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename O&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1less.html">less</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P1&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P2&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>set_union</code> </p>
<p>function template <code>set_symmetric_difference</code> </p>
<p>function template <code>set_difference</code> </p>
<p>function template <code>set_intersection</code> </p>

</div>
</div>
<a id="gab70f44c127c77f896b446afd4bc1ff05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab70f44c127c77f896b446afd4bc1ff05">&#9670;&nbsp;</a></span>template() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename I1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename S1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename I2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename S2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Pred&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1equal__to.html">equal_to</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Proj1&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Proj2&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>contains</code> </p>
<p><code>contains_subrange</code> is a search-based algorithm that checks whether or not a given "needle" range is a subrange of a "haystack" range.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> haystack = std::vector{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};</div>
<div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> needle = std::vector{3, 4, 5};</div>
<div class="line">assert(ranges::contains(haystack, needle));</div>
<div class="line">assert(ranges::contains(haystack, needle, <a class="code" href="structranges_1_1less.html">ranges::less</a>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> not_a_needle = std::vector{4, 5, 3};</div>
<div class="line">assert(not ranges::contains(haystack, not_a_needle));</div>
</div><!-- fragment --><p>The interface supports both iterator-sentinel pairs and range objects. Due to multi-pass iteration, this algorithm requires both ranges to be forward ranges, and the elements' projections need to be comparable when using the predicate. </p><dl class="section pre"><dt>Precondition</dt><dd></dd></dl>

</div>
</div>
<a id="ga31cfc61e5e607409f37adf5e91ef8b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31cfc61e5e607409f37adf5e91ef8b1f">&#9670;&nbsp;</a></span>template() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename Rng1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Rng2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Pred&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1equal__to.html">equal_to</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Proj1&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Proj2&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section pre"><dt>Precondition</dt><dd></dd></dl>

</div>
</div>
<a id="gaeb022dc39b16e3ff52a3537e3c205bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb022dc39b16e3ff52a3537e3c205bc8">&#9670;&nbsp;</a></span>template() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ranges::template </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classC.html">C</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1less.html">less</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename P&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structranges_1_1identity.html">identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function template <code>max</code> </p>
<p>function template <code>minmax</code> </p>
<p>function template <code>min</code> </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae7573663dfa3d476118f64ab918b029c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7573663dfa3d476118f64ab918b029c">&#9670;&nbsp;</a></span>middle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I ranges::middle</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">            <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(begin(rng), std::move(middle), end(rng))</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="astructranges_1_1less_html"><div class="ttname"><a href="structranges_1_1less.html">ranges::less</a></div><div class="ttdef"><b>Definition:</b> comparisons.hpp:50</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
